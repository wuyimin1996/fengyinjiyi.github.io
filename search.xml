<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux服务器安装nginx实现https域名访问]]></title>
    <url>%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85nginx%E5%AE%9E%E7%8E%B0https%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;最近想做一个供自己用的小程序，无奈小程序的网络请求域名必须是https，本地调试可以忽略，但是最后总归要发布，所以就干脆申请域名、购买SSL证书进行安装。&#8195;&#8195;记录一下如何在Linux服务器（CentOS7系统）上安装Nginx并安装证书，实现https访问。购买、下载证书&#8195;&#8195;申请域名就不说了，有了域名之后就是需要购买安全证书了，阿里云有一种安全性比较的证书，有效期一年，可以买这个，是免费的。进入阿里云域名控制台，然后。。。具体操作如下图：&#8195;&#8195;点击下载，将压缩包先下载到桌面待用。安装Nginx&#8195;&#8195;使用终端工具登录自己的Linux服务器，cd 到 /usr/local/ 目录下，下载nginx的包：&#8195;&#8195;wget http://nginx.org/download/nginx-1.12.0.tar.gz&#8195;&#8195;然后解压&#8195;&#8195;tar -xvf nginx-1.12.0.tar.gz&#8195;&#8195;然后先将安装依赖包：&#8195;&#8195;yum install -y gcc&#8195;&#8195;yum install -y gcc-c++&#8195;&#8195;yum install –y pcre pcre-devel&#8195;&#8195;yum install -y zlib zlib-devel&#8195;&#8195;yum install –y openssl openssl-devel&#8195;&#8195;安装依赖时遇到询问是否ok时都输入y，回车。接下来进行安装了：&#8195;&#8195;cd nginx-1.12.0&#8195;&#8195;./configure&#8195;&#8195;make&#8195;&#8195;make install&#8195;&#8195;安装完成之后可以先启动一下，&#8195;&#8195;cd /usr/local/nginx/sbin/&#8195;&#8195;./nginx ，然后看一下进程里有没有nginx，执行 netstat -ltunp ，会发现有一个进程占用着80端口安装证书&#8195;&#8195;将原先下载的证书压缩包解压开来，里面有两个文件，分别是.key和.pem文件，在服务器的/usr/local/nginx/conf/下新建cert文件夹，将这两个文件上传上去，怎么上传就不说了，可以使用rz上传命令。为了后面引用文件，将这两个文件分别重命名为a.key和a.pem。&#8195;&#8195;接着就是编辑 /usr/local/nginx/conf/ 下的配置文件 nginx.conf&#8195;&#8195;vim /usr/local/nginx/conf/nginx.conf&#8195;&#8195;找到以下内容：1234567891011121314151617181920# HTTPS server##server &#123;# listen 443 ssl;# server_name localhost;# ssl_certificate cert.pem;# ssl_certificate_key cert.key;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 5m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;# location / &#123;# root html;# index index.html index.htm;# &#125;#&#125;&#8195;&#8195;不用删除这段注释，在这段注释下面添加以下代码：1234567891011121314151617server &#123; listen 443 ssl; server_name localhost; #这里的localhost就是你的SSL证书绑定的域名 ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125;&#8195;&#8195;回到 /usr/local/nginx/sbin/ ，重启nginx服务 ./nginx -s reload，&#8195;&#8195;如果有报错如下：1nginx: [emerg] the "ssl" parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf:118&#8195;&#8195;说是没有ssl这个模块，那我们需要回到/usr/local/nginx-1.12.0目录(注意： 不是nginx目录，是源码包目录)，执行如下：&#8195;&#8195;./configure --prefix=/usr/local/nginx --with-http_ssl_module&#8195;&#8195;make&#8195;&#8195;注意，这里不能再执行make install（注意一定不要），接下来需要备份之前的配置&#8195;&#8195;cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak&#8195;&#8195;然后将重新编译的nginx覆盖掉现有的nginx，&#8195;&#8195;cp /usr/local/nginx-1.12.0/objs/nginx /usr/local/nginx/sbin/nginx，&#8195;&#8195;可能会报错，显示程序正在运行中“Text file busy”，强制杀掉进程就好了&#8195;&#8195;ps -ef |grep nginx， 然后kill -9对应的进程号就好了。&#8195;&#8195;进程杀掉之后重新执行一下上面的命令，然后再回到 /usr/local/nginx/sbin，启动nginx：&#8195;&#8195;./nginx&#8195;&#8195;最后在客服端的浏览器中输入https://自己的域名，如https://test.aifeier.com （只是举例而已），出现以下页面表示成功！代理指向项目端口&#8195;&#8195;https搞定了，现在我想访问域名后直接指向我在服务器上部署的项目，只需要将/usr/local/nginx/conf/nginx.conf 配置文件修改一下，内容如下：123456789101112131415161718192021server &#123; listen 443 ssl; server_name interview.xujunjie-cv.com; ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; # root html; # index index.html index.htm; proxy_pass http://127.0.0.1:88; #这里就是指向服务器上指定项目的url proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;&#8195;&#8195;修改完重启一下nginx。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>linux</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目（三）整合 Shiro 安全框架]]></title>
    <url>%2FSpring-Boot-%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B4%E5%90%88Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;现在很多中大型项目都有权限管理、登录验证、记住密码等功能，可以在项目对不同角色的用户分配不同的功能权限，从而增加项目的安全性。&#8195;&#8195;Shiro 是比较常用的安全框架，使用也比较简单，主要有登录认证、权限校验、加密、会员管理等功能。简单介绍&#8195;&#8195;先扔一个官方的介绍：Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.译文：Apache Shiro™是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理。借助Shiro易于理解的API，您可以快速轻松地保护任何应用程序 - 从最小的移动应用程序到最大的Web和企业应用程序。&#8195;&#8195;就像上面所说，Shiro 可以执行身份验证(就是登录验证)、授权等功能，而这两个功能也是我们用的最多的。&#8195;&#8195;身份验证是对每一次URL访问都进行拦截认证，其中可以自定义配置拦截规则。&#8195;&#8195;授权是给指定 Controller 中的指定api接口方法进行权限绑定，每次该api接口被访问都会对访问用户进行权限搜索，通过即可访问。使用&#8195;1、引入依赖1234567891011&lt;!-- shiro权限控制 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro-spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&#8195;2、添加配置文件&#8195;&#8195;因为是在 Spring Boot 整合 Shiro ，所以需要在项目中添加 ShiroConfig.java 配置文件，如果不是 Spring Boot 项目，需要在 src/main/resources 下创建相应的配置文件进行配置。ShiroConfig.java 内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import com.aifeier.project.supplement.shiro.UserRealm;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.mgt.SessionManager;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;import org.apache.shiro.web.session.mgt.ServletContainerSessionManager;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.LinkedHashMap;import java.util.Map;/** * Shiro的配置文件 */@Configurationpublic class ShiroConfig &#123; /** * 单机环境，session交给shiro管理 */ @Bean @ConditionalOnProperty(prefix = "renren", name = "cluster", havingValue = "false") public DefaultWebSessionManager sessionManager(@Value("$&#123;renren.globalSessionTimeout:3600&#125;") long globalSessionTimeout)&#123; DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); sessionManager.setSessionValidationSchedulerEnabled(true); sessionManager.setSessionIdUrlRewritingEnabled(false); sessionManager.setSessionValidationInterval(globalSessionTimeout * 1000); sessionManager.setGlobalSessionTimeout(globalSessionTimeout * 1000); return sessionManager; &#125; /** * 集群环境，session交给spring-session管理 */ @Bean @ConditionalOnProperty(prefix = "renren", name = "cluster", havingValue = "true") public ServletContainerSessionManager servletContainerSessionManager() &#123; return new ServletContainerSessionManager(); &#125; @Bean("securityManager") public SecurityManager securityManager(UserRealm userRealm, SessionManager sessionManager) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); securityManager.setSessionManager(sessionManager); securityManager.setRememberMeManager(null); return securityManager; &#125; @Bean("shiroFilter") public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean(); shiroFilter.setSecurityManager(securityManager); shiroFilter.setLoginUrl("/login.html"); shiroFilter.setUnauthorizedUrl("/"); Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put("/swagger/**", "anon"); filterMap.put("/v2/api-docs", "anon"); filterMap.put("/swagger-ui.html", "anon"); filterMap.put("/webjars/**", "anon"); filterMap.put("/swagger-resources/**", "anon"); filterMap.put("/statics/**", "anon"); filterMap.put("/login.html", "anon"); filterMap.put("/sys/login", "anon"); filterMap.put("/favicon.ico", "anon"); filterMap.put("/captcha.jpg", "anon"); filterMap.put("/**", "authc"); shiroFilter.setFilterChainDefinitionMap(filterMap); return shiroFilter; &#125; @Bean("lifecycleBeanPostProcessor") public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; @Bean public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator(); proxyCreator.setProxyTargetClass(true); return proxyCreator; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor(); advisor.setSecurityManager(securityManager); return advisor; &#125;&#125;&#8195;&#8195;代码中 filterMap配置Shiro的拦截规则如下：table th:first-of-type{width:80px}规则用法anon例子/admins/**=anon 没有参数，表示可以匿名使用。authc例如/admins/user/**=authc表示需要认证(登录)才能使用，没有参数roles例子/admins/user/*=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，例如admins/user/=roles[“admin,guest”],每个参数通过才算通过，相当于hasAllRoles()方法。perms例子/admins/user/*=perms[user:add:],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如/admins/user/=perms[“user:add:,user:modify:*”]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。rest例子/admins/user/*=rest[user],根据请求的方法，相当于/admins/user/=perms[user:method] ,其中method为post，get，delete等。port例子/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。authcBasic例如/admins/user/**=authcBasic没有参数表示httpBasic认证ssl例子/admins/user/**=ssl没有参数，表示安全的url请求，协议为httpsuser例如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查&#8195;3、配置自定义身份认证、授权Realm&#8195;&#8195;在 ShiroConfig.java 的securityManager方法可以类叫做UserRealm，这是自定义Shiro的用户数据注入方式，既然是自定义，那么UserRealm这个类需要我们来创建，在项目中创建 UserRealm.java ，继承Shiro的AuthorizingRealm类，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import com.baomidou.mybatisplus.mapper.EntityWrapper;import com.aifeier.project.entity.sys.UserEntity;import com.aifeier.project.service.IUserService;import com.aifeier.project.util.StringUtil;import lombok.extern.slf4j.Slf4j;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;import java.util.Collections;@Slf4jpublic class AuthRealm extends AuthorizingRealm &#123; @Autowired private IUserService iUserService; /** * 授权用户权限 (每次验证权限时调用) * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); UserEntity user = (UserEntity) principals.getPrimaryPrincipal(); // 此处可以对用户的角色进行判断，若是超级管理员，可将全部权限进行绑定 // 这样不用每次新建一个权限不用主动去给管理员进行绑定 user.getMenuList().stream().forEach(m -&gt; &#123; m.getPermissionList().forEach(p -&gt; &#123; authorizationInfo.addStringPermission(p.getPermission_code()); log.info("绑定用户的" + p.getPermission_name() + "(" + p.getPermission_code() + ")权限"); &#125;); &#125;); return authorizationInfo; &#125; /** * 登录时调用 * 认证信息.(身份验证) : Authentication 是用来验证用户身份 如果返回一个SimpleAccount对象则认证通过，如果返回值为空或者异常，则认证不通过。 * 1、检查提交的进行认证的令牌信息 * 2、根据令牌信息从数据源(通常为数据库)中获取用户信息 * 3、对用户信息进行匹配验证 * 4、验证通过将返回一个封装了用户信息的AuthenticationInfo实例 * 5、验证失败则抛出AuthenticationException异常信息 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken)authcToken; //查询用户信息 SysUserEntity user = new SysUserEntity(); user.setUsername(token.getUsername()); // 调用sysUserDao中自定义的SQL查询方法，将权限信息一并查询出来 user = sysUserDao.findOneByUsername(user); //账号不存在 if(user == null) &#123; throw new UnknownAccountException("账号或密码不正确"); &#125; //账号锁定 if(user.getStatus() == 0)&#123; throw new LockedAccountException("账号已被锁定,请联系管理员"); &#125; SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, user.getPassword(), ByteSource.Util.bytes(user.getSalt()), getName()); return info; &#125;&#125;&#8195;&#8195;到这里就Shiro的整合配置就完了，在UserRealm.java 中配置如何去获取一个用户的全部权限，主要在于 doGetAuthorizationInfo 方法的中，先遍历获取用户对应的实体资源(这里指的是菜单)，然后得到每个资源携带的对应的权限。因为在登录就已经将权限一并查询出来存在UserEntity，所以不用在每次验证权限的时候再去查询。&#8195;&#8195;需要注意的是，每个人创建的项目不一样，其用户和权限对应关系不一样，所以需要根据不同情况去修改 doGetAuthorizationInfo 方法 中获取权限的这段代码，将每一个权限都 addStringPermission 到 authorizationInfo ，其他配置都是可以直接复制粘贴的。&#8195;&#8195;这里说明一下本样例项目的用户和权限关系，本项目由用户表(user)、角色表(role)、菜单表(menu)、权限表(permission)，用户角色关系表(user_role)、角色菜单关系表(role_menu)、菜单权限关系表(menu_permission)，菜单相当于实体资源，角色拥有的对应的实体资源，实体资源携带权限，最后用户只需要绑定相应的角色就好了。]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Velocity的代码生成器]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EVelocity%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;最近在回顾 Java Web 项目，发现大多 SpringBoot 项目框架中都带有一个代码生成器模块，可以快速的生成大部分项目源码文件，这样节省了很多重复编码的工作时间，而且可以根据自己规定的代码规范去生成代码。&#8195;&#8195;代码生成器就是先定义好一些模板规范，然后再启动它批量生成一系列的代码。那如何根据自己规定的模板去批量生产代码呢？这就要用到模板引擎，本文主要简单记录 Velocity 模板引擎是如何根据模板规范去生成代码文件。简单介绍Velocity is a Java-based template engine. It permits anyone to use a simple yet powerful template language to reference objects defined in Java code.译文：Velocity是一个基于Java的模板引擎。它允许任何人使用简单但功能强大的模板语言来引用Java代码中定义的对象。&#8195;&#8195;以上是官方对Velocity的介绍，更多介绍请移步。Velocity 是一个基于Java的模板引擎，其提供一个Context容器，可以在容器里存储一些信息，然后模板中根据一些规定的语法进行获取，我们可以用Velocity来生成Java、HTML、CSS、SQL等代码。使用&#8195;&#8195;本文样例是在SpringBoot项目框架中使用的，IDE用的是 IntelliJ IDEA 。首先我们先创建一个生成器工具类 Velocity.java，代码如下：12345678910111213141516171819202122232425262728293031import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.VelocityEngine;import org.apache.velocity.runtime.RuntimeConstants;import org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;import java.io.*;import java.util.ArrayList;import java.util.List;public class Velocity &#123; public static void main(String[] args) &#123; // 初始化模板引擎 VelocityEngine velocityEngine = new VelocityEngine(); velocityEngine.setProperty(RuntimeConstants.RESOURCE_LOADER, "classpath"); velocityEngine.setProperty("classpath.resource.loader.class", ClasspathResourceLoader.class.getName()); velocityEngine.init(); // 获取模板文件 Template template = velocityEngine.getTemplate("template.vm", "UTF-8"); // 设置变量 VelocityContext velocityContext = new VelocityContext(); velocityContext.put("myName", "埃菲尔"); List list = new ArrayList(); list.add("第一条信息"); list.add("第二条信息"); velocityContext.put("list", list); StringWriter stringWriter = new StringWriter(); template.merge(velocityContext,stringWriter); System.out.println(stringWriter.toString()); &#125;&#125;&#8195;&#8195;生成器工具类创建好了，就像是我们铁匠用于锻造的铁炉已经搭建好了，剩下的就是给铁炉一个模具，用来打造成我们想要的铁制品，所以接下来就是创建一个模板。在resources目录下新建一个模板文件 template.vm ，内容如下：12345这是我的名字: $myName下面是list循环：#foreach($i in $list) $i#end&#8195;&#8195;最后在运行上面的生成器工具类，会在控制台中打印出以下内容：1234这是我的名字: 埃菲尔下面是list循环： 第一条信息 第二条信息输出文件&#8195;&#8195;光是在控制台输出并不是我们想要的，我们需要的是生成一些代码文件，比如java类文件、HTML文件之类的，继续优化一下生成器和模板文件，实现生成Java实体类代码并输出到文件。修改 Velocity.java 文件如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.VelocityEngine;import org.apache.velocity.runtime.RuntimeConstants;import org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;import java.io.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class HelloVelocity &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream fos = null; BufferedWriter writer = null; // 初始化模板引擎 VelocityEngine velocityEngine = new VelocityEngine(); velocityEngine.setProperty(RuntimeConstants.RESOURCE_LOADER, "classpath"); velocityEngine.setProperty("classpath.resource.loader.class", ClasspathResourceLoader.class.getName()); velocityEngine.init(); // 获取模板文件 Template template = velocityEngine.getTemplate("hellovelocity.vm", "UTF-8"); // 设置变量 VelocityContext velocityContext = new VelocityContext(); velocityContext.put("package","com.aifeier"); // 设置包名 velocityContext.put("comments","这是用户表的entity类"); // 设置类说明 velocityContext.put("author","埃菲尔"); //设置作者名 velocityContext.put("email","XXXXXXXXXXXX@qq.com"); //设置作者邮箱 velocityContext.put("datetime","2018-12-26"); //设置类文件创建时间 velocityContext.put("tableName","user"); // 设置数据表名称 velocityContext.put("className","User"); //设置entity实体类类名 List&lt;Map&lt;String, Object&gt;&gt; columns = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); //设置数据表的表属性 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("comments","id字段"); // 设置字段的备注 map.put("columnName","id"); //设置字段名称 map.put("attrname","id"); //设置字段对应的变量名称 map.put("attrType","Integer"); //设置字段类型 columns.add(map); map = new HashMap&lt;String, Object&gt;(); map.put("comments","username字段"); map.put("columnName","username"); map.put("attrname","username"); map.put("attrType","String"); columns.add(map); map = new HashMap&lt;String, Object&gt;(); map.put("comments","mail字段"); map.put("columnName","mail"); map.put("attrname","mail"); map.put("attrType","String"); columns.add(map); velocityContext.put("columns",columns); // 设置entity实体类的变量和set、get方法// StringWriter stringWriter = new StringWriter();// template.merge(velocityContext,stringWriter);// System.out.println(stringWriter.toString()); File file = new File("D://UserEntity.java"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; fos = new FileOutputStream(file); writer = new BufferedWriter(new OutputStreamWriter(fos, "UTF-8"));// 设置写入的文件编码,解决中文问题 template.merge(velocityContext, writer); if (writer != null) writer.close(); if (fos != null) fos.close(); &#125;&#125;&#8195;&#8195;修改模板文件 template.vm ，内容如下：12345678910111213141516171819202122232425262728293031323334353637383940package $&#123;package&#125;.entity;import com.baomidou.mybatisplus.annotations.TableId;import com.baomidou.mybatisplus.annotations.TableName;import java.io.Serializable;import java.util.Date;/*** $&#123;comments&#125;** @author $&#123;author&#125;* @email $&#123;email&#125;* @date $&#123;datetime&#125;*/@TableName("$&#123;tableName&#125;")public class $&#123;className&#125;Entity implements Serializable &#123;private static final long serialVersionUID = 1L;#foreach ($column in $columns) /** * $column.comments */ #if($column.columnName == $pk.columnName) @TableId #end private $column.attrType $column.attrname;#end#foreach ($column in $columns) /** * 设置：$&#123;column.comments&#125; */ public void set$&#123;column.attrName&#125;($column.attrType $column.attrname) &#123; this.$column.attrname = $column.attrname; &#125; /** * 获取：$&#123;column.comments&#125; */ public $column.attrType get$&#123;column.attrName&#125;() &#123; return $column.attrname; &#125;#end&#125;&#8195;&#8195;然后执行生成器成功后，会在D盘生成一个UserEntity.java 文件， 内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.aifeier.entity;import com.baomidou.mybatisplus.annotations.TableId;import com.baomidou.mybatisplus.annotations.TableName;import java.io.Serializable;import java.util.Date;/*** 这是用户表的entity类** @author 埃菲尔* @email XXXXXXXXXXXX@qq.com* @date 2018-12-26*/@TableName("user")public class UserEntity implements Serializable &#123;private static final long serialVersionUID = 1L; /** * id字段 */ private Integer id; /** * username字段 */ private String username; /** * mail字段 */ private String mail; /** * 设置：id字段 */ public void set$&#123;column.attrName&#125;(Integer id) &#123; this.id = id; &#125; /** * 获取：id字段 */ public Integer get$&#123;column.attrName&#125;() &#123; return id; &#125; /** * 设置：username字段 */ public void set$&#123;column.attrName&#125;(String username) &#123; this.username = username; &#125; /** * 获取：username字段 */ public String get$&#123;column.attrName&#125;() &#123; return username; &#125; /** * 设置：mail字段 */ public void set$&#123;column.attrName&#125;(String mail) &#123; this.mail = mail; &#125; /** * 获取：mail字段 */ public String get$&#123;column.attrName&#125;() &#123; return mail; &#125;&#125;&#8195;&#8195;以上是 Velocity 模板引擎的简单使用过程，具体想要在实际项目中应用的话需要再自行优化代码。分享一个人人开源网的现成开源的代码生成器，下载链接。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Velocity</tag>
        <tag>代码生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目（二）整合Druid数据库连接池]]></title>
    <url>%2FSpring%20Boot%20%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B4%E5%90%88Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;Druid 是一个数据连接池，是阿里巴巴的一个开源项目，整个项目由数据库连接池、插件框架和SQL解析器组成。同名还有一个大数据分析系统，也叫Druid，需要区分一下。&#8195;&#8195;本文记录 Spring Boot 项目整合 Druid 数据库连接池。添加依赖&#8195;&#8195;在 Spring Boot 项目中的maven配置文件中引入依赖：123456&lt;!-- 数据库连接池用的是阿里巴巴的druid，结合了c3p0、dbcp等其他连接池的优点 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;配置文件&#8195;&#8195;1、在项目配置文件application.yml(或者application.properties)中配置连接池：123456789101112131415161718192021spring: datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://yourIP:yourPort/demo?useUnicode=true&amp;amp;characterEncoding=UTF-8 username: yourUsername password: yourPassword driver-class-name: com.mysql.jdbc.Driver connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 minIdle: 5 validationQuery: SELECT 1 FROM DUAL initialSize: 5 #初始化数量 maxWait: 60000 #最大连接等待超时时间 poolPreparedStatements: true #打开PSCache maxPoolPreparedStatementPerConnectionSize: 20 #并且指定每个连接PSCache的大小 testOnBorrow: false testWhileIdle: true minEvictableIdleTimeMillis: 300000 timeBetweenEvictionRunsMillis: 60000 testOnReturn: false maxActive: 20 #最大活跃数 filters: stat,wall&#8195;&#8195;2、在 Spring Boot 的配置文件夹中添加DruidConfig.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.aifeier.demo.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import javax.sql.DataSource;import java.sql.SQLException;@Data@Configuration@ConfigurationProperties(prefix = "spring.datasource")public class DruidConfig &#123; private String type; private String url; private String username; private String password; private String driverClassName; private String connectionProperties; private int minIdle; private String validationQuery; private int initialSize; private int maxWait; private boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private boolean testOnBorrow; private boolean testWhileIdle; private int minEvictableIdleTimeMillis; private int timeBetweenEvictionRunsMillis; private boolean testOnReturn; private int maxActive; private String filters; @Bean //声明其为Bean实例 @Primary //在同样的DataSource中，首先使用被标注的DataSource public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setDriverClassName(driverClassName); dataSource.setDbType(type); dataSource.setMinIdle(minIdle); dataSource.setValidationQuery(validationQuery); dataSource.setInitialSize(initialSize); dataSource.setMaxWait(maxWait); dataSource.setPoolPreparedStatements(poolPreparedStatements); dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setTimeBetweenConnectErrorMillis(timeBetweenEvictionRunsMillis); dataSource.setTestOnReturn(testOnReturn); dataSource.setMaxActive(maxActive); try &#123; dataSource.setFilters(filters); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; dataSource.setConnectionProperties(connectionProperties); return dataSource; &#125; /** * 注册一个StatViewServlet * * @return */ @Bean public ServletRegistrationBean DruidStatViewServle() &#123; // org.springframework.boot.context.embedded.ServletRegistrationBean提供类的进行注册. ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); // 添加初始化参数：initParams // 白名单： servletRegistrationBean.addInitParameter("allow", "127.0.0.1"); // IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not // permitted to view this page. servletRegistrationBean.addInitParameter("deny", "192.168.1.73"); // 登录查看信息的账号密码. servletRegistrationBean.addInitParameter("loginUsername", "admin"); servletRegistrationBean.addInitParameter("loginPassword", "123456"); // 是否能够重置数据. servletRegistrationBean.addInitParameter("resetEnable", "false"); return servletRegistrationBean; &#125; /** * 注册一个：filterRegistrationBean * * @return */ @Bean public FilterRegistrationBean druidStatFilter() &#123; //创建过滤器 FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); //设置过滤器过滤路径 filterRegistrationBean.addUrlPatterns("/*"); //忽略过滤的形式 filterRegistrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"); return filterRegistrationBean; &#125;&#125;&#8195;&#8195;到这Druid的配置算是完了，要是想进入Druid后台查看监控数据，可以启动项目后在浏览器里输入网址打开 http://127.0.0.1:8080/druid/ 进行访问，登录名和密码在上面的DruidConfig.java中进行配置：123// 登录查看信息的账号密码.servletRegistrationBean.addInitParameter("loginUsername", "admin");servletRegistrationBean.addInitParameter("loginPassword", "123456");小坑&#8195;&#8195;Spring Boot 整合 Mybatis-Plus 和 Druid时，在配置Mybatis-plus时需要获取DataSource的Bean实例，MybatisPlusConfig.java 的配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Autowiredprivate DataSource dataSource;@Autowiredprivate MybatisProperties properties;@Autowiredprivate ResourceLoader resourceLoader = new DefaultResourceLoader();@Autowired(required = false)private Interceptor[] interceptors;@Autowired(required = false)private DatabaseIdProvider databaseIdProvider;/*** 这里全部使用mybatis-autoconfigure 已经自动加载的资源。不手动指定* 配置文件和mybatis-boot的配置文件同步** @return*/@Beanpublic MybatisSqlSessionFactoryBean mybatisSqlSessionFactoryBean() &#123; MybatisSqlSessionFactoryBean mybatisPlus = new MybatisSqlSessionFactoryBean(); System.out.println("*************" + dataSource); mybatisPlus.setDataSource(dataSource); mybatisPlus.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) &#123; mybatisPlus.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); &#125; mybatisPlus.setConfiguration(properties.getConfiguration()); if (!ObjectUtils.isEmpty(this.interceptors)) &#123; mybatisPlus.setPlugins(this.interceptors); &#125; MybatisConfiguration mc = new MybatisConfiguration(); mc.setDefaultScriptingLanguage(MybatisXMLLanguageDriver.class); mybatisPlus.setConfiguration(mc); if (this.databaseIdProvider != null) &#123; mybatisPlus.setDatabaseIdProvider(this.databaseIdProvider); &#125; if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123; mybatisPlus.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); &#125; if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123; mybatisPlus.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); &#125; if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123; mybatisPlus.setMapperLocations(this.properties.resolveMapperLocations()); &#125; return mybatisPlus;&#125;&#8195;&#8195;而这个Bean实例就是Druid配置中的DataSource Bean实例，如下（完整代码看上面）：1234567891011121314151617181920212223242526272829@Bean //声明其为Bean实例@Primary //在同样的DataSource中，首先使用被标注的DataSourcepublic DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setDriverClassName(driverClassName); dataSource.setDbType(type); dataSource.setMinIdle(minIdle); dataSource.setValidationQuery(validationQuery); dataSource.setInitialSize(initialSize); dataSource.setMaxWait(maxWait); dataSource.setPoolPreparedStatements(poolPreparedStatements); dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setTimeBetweenConnectErrorMillis(timeBetweenEvictionRunsMillis); dataSource.setTestOnReturn(testOnReturn); dataSource.setMaxActive(maxActive); try &#123; dataSource.setFilters(filters); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; dataSource.setConnectionProperties(connectionProperties); return dataSource;&#125;&#8195;&#8195;项目会报错，提示出现dbType不支持：1Invocation of init method failed; nested exception is com.baomidou.mybatisplus.exceptions.MybatisPlusException: Error: GlobalConfigUtils setMetaData Fail ! Cause:java.lang.IllegalStateException: dbType not support : com.alibaba.druid.pool.DruidDataSource&#8195;&#8195;多番测试，是配置文件中 Druid 的 dataSource 属性中的 filters 属性出了问题，Druid 官方文档表明 filters 可以设置多个值，用逗号分开，按照要求写在MybatisPlusConfig中就是会报错，所以干脆就不在DruidConfig中将 filters Set到 dataSource 实例中，对Druid也不会有什么影响，毕竟配置文件中已经设置了自己想要的值。所以，在DruidConfig.java中将以下代码进行注释：12345// try &#123;// dataSource.setFilters(filters);// &#125; catch (SQLException e) &#123;// System.err.println("druid configuration initialization filter: "+ e);// &#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目（一）整合 Mybatis Plus]]></title>
    <url>%2FSpring%20Boot%20%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B4%E5%90%88%20Mybatis%20Plus.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;Spring 项目结合 Spring Boot 框架来搭建后台是目前比较主流的技术，不仅简化了配置文件，也让 Spring 使用起来更加方便。&#8195;&#8195;Spring Boot 整合 MyBatis-Plus （基于Mybatis的第三方持久层框架）让数据操作更加简单、优雅。简单介绍一下&#8195;&#8195;先给出官方的介绍：MyBatis-Plus（简称 MP）是一个 MyBatis(http://www.mybatis.org/mybatis-3/) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。&#8195;&#8195;Mybatis-Plus 主要也是为了简化 Mybatis 的开发，比如单纯使用 Mybatis 去进行数据增删改查甚至更复杂的数据操作需要创建很多xml文件，写很多 SQL 代码，如果项目小点还好，要是中大型项目，这么多的 xml 以及密密麻麻的 SQL 代码维护起来着实让人头疼，我自己的大学毕业设计就是一个很好的例子。而 Mybatis-Plus 呢，将很多 CRUD 数据操作方法进行整合封装，在service、servicImpl、mapper、xml等方面都大大减少了代码量，还有 Mybatis-Plus 的代码生成器也设计得比较好，几乎不用我们手动去创建刚刚说的这些文件包括Entity实体类。Mybatis-Plus 还有热加载、代码生成、分页、性能分析等功能一应俱全。&#8195;&#8195;不说了，能动手就别唠叨！添加依赖&#8195;&#8195;目前 Mybatis-Plus 已经到了3.0.6版本，官方指明MP(Mybatis-Plus缩写)3.0要求 JDK 版本要在8以上。&#8195;&#8195;首先需要创建Spring Boot 项目，IDEA 已经集成了 Spring Initializr 工具，可以快速创建 Spring Boot 项目，默认已经引入了Spring Boot Staeter 父工程，要不是快速创建的项目，需要先引入 Spring Boot Staeter 父工程：123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&#8195;&#8195;然后引入 spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、lombok、mysql、druid 依赖：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;!-- Spring 核心模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring 测试模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 如果需要可以引入Spring Web 模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Lombok可以减少很多重复代码的书写，比如说getter/setter/toString等方法的编写，还有日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- Mybatis-Plus 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql 依赖，maven库有更高版本如8.0，这里用5.1.22 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池用的是阿里巴巴的druid，结合了c3p0、dbcp等其他连接池的优点 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;配置&#8195;&#8195;项目文件结构目录如下：&#8195;&#8195;快速构建的Spring Boot的配置文件一般是application.properties的properties格式文件，可以自行修改文件后缀为yml，不改也可以。在application.yml中配置如下：123456789101112131415161718192021spring: datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://yourIP:yourPort/yourDatabase username: yourUsername password: yourPassword driver-class-name: com.mysql.jdbc.Driver connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 minIdle: 5 validationQuery: SELECT 1 FROM DUAL initialSize: 5 maxWait: 60000 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 testOnBorrow: false testWhileIdle: true minEvictableIdleTimeMillis: 300000 timeBetweenEvictionRunsMillis: 60000 testOnReturn: false maxActive: 20 filters: stat,wall##&#8195;&#8195;用本地Mysql创建本地连接，再新建一个数据库(名称为demo)，然后新建一张数据库(名称为users)，添加字段如下：1234567CREATE TABLE `users` ( `id` int(10) NOT NULL AUTO_INCREMENT, `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `age` int(1) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;创建实体类、service、mapper&#8195;&#8195;编写实体类 UserEntity.java，如下：12345678910111213package com.aifeier.demo.entity;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@TableName("users")@Datapublic class UserEntity &#123; private long id; private String username; private String sex; private Integer age;&#125;&#8195;&#8195;编写 IUserService.java 接口如下：12345678package com.aifeier.demo.service;import com.aifeier.demo.entity.UserEntity;import com.baomidou.mybatisplus.extension.service.IService;public interface IUserService extends IService&lt;UserEntity&gt; &#123;&#125;&#8195;&#8195;编写 UserServiceImpl.java 实现类接口如下：12345678910111213package com.aifeier.demo.service.impl;import com.aifeier.demo.entity.UserEntity;import com.aifeier.demo.mapper.UserMapper;import com.aifeier.demo.service.IUserService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, UserEntity&gt; implements IUserService &#123;&#125;&#8195;&#8195;编写 UserMapper.java 接口如下：123456789101112package com.aifeier.demo.mapper;import com.aifeier.demo.entity.UserEntity;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;@Mapper@Repositorypublic interface UserMapper extends BaseMapper&lt;UserEntity&gt; &#123;&#125;开始使用&#8195;&#8195;接下来直接在test测试单元中直接进行测试，在 DemoApplicationTests.java 中添加如下：123456789101112131415161718192021222324252627package com.aifeier.demo;import com.aifeier.demo.entity.UserEntity;import com.aifeier.demo.service.IUserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private IUserService iUserService; @Test public void contextLoads() &#123; UserEntity user = new UserEntity(); user.setUsername("埃菲尔"); user.setSex("男"); user.setAge(18); boolean flag = iUserService.save(user); System.out.println(flag ? "添加成功" : "添加失败"); &#125;&#125;&#8195;&#8195;运行单元测试就能看到控制台输出“添加成功”。自行编写SQL&#8195;&#8195;开发中当然光靠Mybatis-Plus 中封装好的 CRUD 方法是不够的，有时有一些复杂需求需要自行编写SQL来获取数据，比如有时候需要在插入一条记录后同时返回插入记录的id主键值，那下面就实现这一需求。&#8195;&#8195;首先在配置文件目录中resources中新建mybatis文件夹，在mybatis文件夹里新建mapper文件夹，在mapper文件夹中新建UserMapper.xml，内容如下：1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.aifeier.demo.mapper.UserMapper"&gt; &lt;insert id="insertResultId" parameterType="UserEntity" keyProperty="id" useGeneratedKeys="true"&gt; INSERT INTO users(username,sex,age) VALUES(#&#123;username&#125;,#&#123;sex&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt;&#8195;&#8195;文件目录在上面截图上可见。在application.yml中配置mybatis-plus,如下：1234567891011121314151617181920212223#mybatismybatis-plus: mapper-locations: classpath:/mybatis/mapper/*.xml typeAliasesPackage: com.aifeier.demo.entity #实体扫描，多个package用逗号或者分号分隔 config-locations: classpath:/mybatis/mybatis-config.xml global-config: #刷新mapper 调试神器 db-config: id-type: id_worker #主键类型 0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID UUID"; field-strategy: not_empty #字段策略 0:"忽略判断",1:"非 NULL 判断"),2:"非空判断" column-underline: true #驼峰下划线转换 #capital-mode: true #数据库大写下划线转换 logic-delete-value: Y #逻辑删除配置 logic-not-delete-value: N db-type: mysql refresh: true #自定义填充策略接口实现 #meta-object-handler: com.baomidou.springboot.xxx #自定义SQL注入器 #sql-injector: com.baomidou.springboot.xxx configuration: map-underscore-to-camel-case: true cache-enabled: false&#8195;&#8195;这是声明mapper接口文件所对应的xml位置以及mybatis的一些配置文件。然后修改IUserService.java，如下：123public interface IUserService extends IService&lt;UserEntity&gt; &#123; Integer insertResultId(UserEntity userEntity);&#125;&#8195;&#8195;修改UserServiceImpl.java，如下：123456789@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, UserEntity&gt; implements IUserService &#123; @Autowired private UserMapper userMapper; @Override public Integer insertResultId(UserEntity userEntity) &#123; return userMapper.insertResultId(userEntity); &#125;&#125;&#8195;&#8195;修改UserMapper.java，如下：12345@Mapper@Repositorypublic interface UserMapper extends BaseMapper&lt;UserEntity&gt; &#123; Integer insertResultId(UserEntity userEntity);&#125;&#8195;&#8195;好了，接下来可以再测试类中编写测试代码，如下：1234567891011121314151617public class DemoApplicationTests &#123; @Autowired private IUserService iUserService; @Test public void contextLoads() &#123; UserEntity user = new UserEntity(); user.setUsername("埃菲尔小号"); user.setSex("男"); user.setAge(18);// boolean flag = iUserService.save(user);// System.out.println(flag ? "添加成功" : "添加失败"); iUserService.insertResultId(user); System.out.println("返回的id为：" + user.getId()); &#125;&#125;&#8195;&#8195;完成，运行后能返回插入记录的id。其他&#8195;&#8195;MybatisPlusConfig.java这个配置文件主要是一些Mybatis-Plus的Bean注入，例如配置 datasource， sqlSessionFactory, transaction manager 等等，晒一下简单的配置，仅供参考：12345678910111213141516171819202122232425262728293031323334353637package com.aifeier.demo.config;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor;import org.mybatis.spring.mapper.MapperScannerConfigurer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MybatisPlusConfig &#123; // 一些配置， 例如，配置 datasource， sqlSessionFactory, transaction manager 等等 /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; /** * 相当于顶部的： * &#123;@code @MapperScan("com.baomidou.cloud.service.*.mapper*")&#125; * 这里可以扩展，比如使用配置文件来配置扫描Mapper的路径 */ @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer(); scannerConfigurer.setBasePackage("com.baomidou.cloud.service.*.mapper*"); return scannerConfigurer; &#125; /** * SQL执行效率插件 */ @Bean public PerformanceInterceptor performanceInterceptor() &#123; return new PerformanceInterceptor(); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Mybatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端 Web 页面调试器 vConsole]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-Web-%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95%E5%99%A8%20vConsole.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;目前移动端Web开发越来越大众普遍，越来越多的前段框架技术都支持移动端兼容和适配，但是不得不说，移动端开发过程中要在手机上调试真的很麻烦，毕竟手机浏览器不能像在 PC 上一样，直接F12就弹出调试器，看到我们再控制台输出的调试信息，有时万般无奈只能使用alert来输出，这真是一个痛点！&#8195;&#8195;腾讯的 vConsole 插件能帮我们解决这个问题！下载 安装&#8195;&#8195;首先需要下载 vConsole 的最新版本，或者直接使用 npm 安装：1npm install vconsole然后复制 dist/vconsole.min.js 到自己的项目中。接着就是将这个插件引入到项目中：&#8195;&#8195;1、使用 script 来直接直接引入 vConsole 模块。单页面应用直接在入口Html文件的 &lt;hean&gt;&lt;/hean&gt; 中引入：123456&lt;head&gt; &lt;script src="path/to/vconsole.min.js"&gt;&lt;/script&gt; &lt;script&gt; var vConsole = new VConsole(); &lt;/script&gt;&lt;/head&gt;&#8195;&#8195;注意：这里的path/to/指的是vconsole.min.js文件的路径，多页面应用要在需要进行调试的每个页面都引入。&#8195;&#8195;2、在入口js文件中使用 require() 引入模块：12var VConsole = require('path/to/vconsole.min.js');var vConsole = new VConsole();&#8195;&#8195;上面第一行代码只是引入了vConsole的原型，并不会直接在页面插入调试器，需要第二行代码来实例化一个VConsole对象才可以，所以注意，一定要手动进行实例化。&#8195;&#8195;3、如果是在Vue-cli项目里，那先安装vConsole到dependencies中 npm install vconsole ，然后在main.js中引入：123import vConsole from 'vconsole'const vconsole = new vConsole()Vue.use(vconsole)&#8195;&#8195;按照上面的方法就可以再移动端进行调试了，需要更加详细地了解vConsole，可以去GitHub上看文档。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>调试</tag>
        <tag>vConsole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex 用法总结]]></title>
    <url>%2FVuex-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;很早就开始使用Vue框架了，一直没有用到Vuex，也是最近才开始学着使用Vuex进行全局的状态管理，不得不说，是真的好用。&#8195;&#8195;百度一下就能找到Vuex的官方文档，介绍的很官方化，可就是因为太官方化了，开始学习的时候总是看的似懂非懂，相信很多人也会有这样的感觉，所以博主将Vuex以自己所理解的程度来用自己的话简单记录一下使用方法。对于资深的前端大神们，要是愿意对本文提出意见，当然最好。简单介绍&#8195;&#8195;先说说Vuex是个什么东西吧。先给大家一个官方文档传送门，官方是这样介绍的：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&#8195;&#8195;意思就是 Vuex 是一个 Vue 程序的状态管理器，对 Vue 中的一些进行及时更新。我们在项目会使用全局变量来存储一些频繁被使用的信息，比如用户信息、购物车信息等等，这些信息存在全局中随时取用，比起每次去网络请求数据会更加方便、高效。Vue 应用中也会需要用到全局变量来管理一些全局信息，Vuex就是这么一个东东。 不仅如此，Vuex 中管理的状态，一旦改变，可以及时渲染到整个应用中。进入正题引用根据官方的文档描述，引用方式有两种，一种就是直接引用全局 Script 的文件，但是要注意必须 Vuex 要在 Vue 引用之后再引用，如下：12&lt;script src="/path/to/vue.js"&gt;&lt;/script&gt;&lt;script src="/path/to/vuex.js"&gt;&lt;/script&gt;注意：上面应用地址/path/to只是样例，真正的地址是 Vue 和 Vuex 的 CDN ，官网上都有。&#8195;&#8195;若是在一个模块化的打包系统中，需要显式地通过 Vue.use() 来安装 Vuex：123import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)一般都会用第二种方法，不过需要先进行 Vue 和 Vuex 的安装。基本的 Vuex 结构&#8195;&#8195;Vuex 基本结构如下：12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;)&#8195;&#8195;这是Vue-cli 搭建Vue项目时自带就生成Vuex模板(博主这里用的Vue-cli 3.0以上的版本，如果在初始化项目的时候勾选了 Vuex 组件才会有内容如上的store.js文件，位于src目录下)，单词 store 是仓库的意思，很明显，Vuex将存储全局信息的地方称之为仓库。创建好了基本的Vuex 仓库之后需要在 Vue 对象中引入它(注意：一个 Vue 项目应用中只能有一个 Vuex 仓库，足够了！)，具体是在项目入口 main.js 文件中引用，如下：123456789101112import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app')&#8195;&#8195;如果是简单的小型项目，只需要一个store.js即可，毕竟没有太多信息量需要全局管理，若是中大型项目，可以新建一个store文件夹，里面再新建sate.js、mutation.js、actions.js、getter.js分别对应仓库的state、mutations、actions、getter，最后再新建一个index.js，new Vuex.Store()将这四个文件都引用进去即可。&#8195;&#8195;综上所述，Vuex 其实并不是很复杂，就是一个管理 Vue 项目的全局状态信息的管理器，称为store（仓库），主要包含State、Mutation、Action三个核心部分，getter可用可不用看，看自己的项目需要。Vuex 仓库之 State&#8195;&#8195;Vuex 仓库的核心部分State，官方形容是驱动应用的数据源，我的理解就是这是一个存放数据的地方，就相当于 Vue 中的data属性一样，全部的变量就放在这里，里面存放的数据是项目全局都可访问的状态信息。不多说，直接上代码！&#8195;&#8195;我们在sate里设置一个数据源，就按照官网的例子来吧，设置一个变量叫count，初始值为0，如下：1234567891011export default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;)&#8195;&#8195;然后在新建两个Vue模板，分别为 ATest.vue 和 BTest.vue 就放在view目录下(这是Vue-cli 3.0以上项目才有的目录，就是视图模板的文件夹)，Vue 路由里配置这两个模板组件，怎么配置就不说了，这是 Vue 的知识，不会的请移步Vue菜鸟教程。ATest.vue 和 BTest.vue 都用 来输出全局状态count的值，两个模板的内容都如下：123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是ATest页面&lt;/h1&gt; &lt;h2&gt;全局状态count：&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&#8195;&#8195;BTest.vue 中标题就写“这是BTest页面”。然后把项目跑起来，可以看到 ATest 和 BTest 两个视图中都能显示count的值，效果如下:&#8195;&#8195;要是在store仓库中修改state中的count值为10，那么这两个视图中的count也会变成10。但是这样子去写不够优雅，不够漂亮，所以下面介绍三种比较优雅的获取仓库共享值得方法。赋值方法一：通过computed的计算属性直接赋值&#8195;&#8195;computed是 Vue 的属性，主要用来监控所定义的变量发生变化，变量不需要在data属性中定义，只需要在computed中定义，然后就可以在页面上进行双向数据绑定进行页面渲染，还有就是computed属性可以在变量输出前就对其值进行改变，那我们就用这个方法来将store.js中的state里的值赋值给data。12345computed: &#123; count () &#123; return this.$store.state.count &#125;&#125;然后将模板中的 $store.state.count 改成 count，再运行项目发现也是能取到值。赋值方法二：在computed中通过mapState的对象来赋值&#8195;&#8195;mapState是一个 Vuex 的辅助函数，直接上代码。首先我们需要引用mapState。1import &#123;mapState&#125; from 'vuex';&#8195;&#8195;然后还在computed计算属性里写如下代码：123computed: mapState(&#123; count: state =&gt; state.count // 此处使用EC6的箭头函数语法，理解为传入state对象，返回state.count属性&#125;)&#8195;&#8195;上面用的ES6的箭头函数语法，不了解可以先去百度了解一下，不是很难，就是换了一种函数的写法，显得比较简洁优化、高端大气。赋值方法三：在computed中通过mapState的数组来赋值&#8195;&#8195;其实3种赋值的方法都是在computed中进行，只是一个比一个更加简洁、优雅。这种方法也是用mapState辅助函数，但是更加简单，如下：1computed: mapState(["count"]) //映射this.count 为 store.state.count&#8195;&#8195;这样也可以拿到state的值，大多都是用这种方法。Vuex 仓库之 Mutation&#8195;&#8195;State 就像是 Vue 里的data属性一样用来存放变量，那么 Mutation 就好比是 Vue 中的methods一样，用来存放方法，只要是用于更改store仓库里的变量唯一放方法就是用 Mutation。先给出一段官方的介绍：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。&#8195;&#8195;Mutation的使用就是提交一个commit指令来告诉 Vuex 要使用哪个方法来进行对变量进行操作，基本语法是$store.commit(String methos)，先来一个简单的样例代码，在ATest.vue的Html部分加上两个按钮事件，完整代码如下：123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是ATest页面&lt;/h1&gt; &lt;h2&gt;全局状态count：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;br&gt; &lt;button @click="$store.commit('add')"&gt;对count进行+1操作&lt;/button&gt; &lt;button @click="$store.commit('reduce')"&gt;对count进行-1操作&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;store.js中再修改mutation属性：12345678mutations: &#123; add (state) &#123; state.count += 1 &#125;, reduce (state) &#123; state.count -= 1 &#125;&#125;&#8195;&#8195;运行项目，发现点击按钮就会进行相应的加减操作，在ATest视图操作完了可以跳转去BTest瞧瞧count是不是也相应的改变了。在commit()方法中不仅可以传方法名，也能传入一个参数，通过我们所传入的值来进行加减。具体代码如下：123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是ATest页面&lt;/h1&gt; &lt;h2&gt;全局状态count：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;br&gt; &lt;button @click="$store.commit('add',5)"&gt;对count进行+1操作&lt;/button&gt; &lt;button @click="$store.commit('reduce',5)"&gt;对count进行-1操作&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;store.js中再修改mutation属性：12345678mutations: &#123; add (state,n) &#123; state.count += n &#125;, reduce (state,n) &#123; state.count -= n &#125;&#125;&#8195;&#8195;这样传入是多少，就是进行多少的加减操作。上面说到State有辅助函数mapState，方便对变量的取值，Vuex 倒也是不偏心，Mutations也有辅助函数mapMutations。通过mapMutations模板获取Mutations方法&#8195;&#8195;实际开发中当然不希望每次提交commit都直接在button的click事件中进行，而mapMutations辅助函数能直接让button的点击事件指向方法名，就像@click=&quot;add&quot;，实现如下：&#8195;&#8195;1、先引用辅助函数mapState:1import &#123;mapMutations&#125; from 'vuex';&#8195;&#8195;然后在 Vue 的methosd属性中添加mapMutations：123methods: &#123; ...mapMutations(['add','reduce'])&#125;&#8195;&#8195;mapMutations中的数组内的每一个项值就相当于方法名，这样就可以直接在点击事件指向方法名，就像这样：12&lt;button @click="add"&gt;对count进行+1操作&lt;/button&gt;&lt;button @click="reduce"&gt;对count进行-1操作&lt;/button&gt;Vuex 仓库之 Actions&#8195;&#8195;Actions其实就是Mutations的升级版，因为他们的功能基本一样，只不过和 Mutations 不一样的是，Actions 是异步的，而 Mutations 是同步的。同步就是代码必须要一行一行执行，请求必须要一个接着一个，而异步不是这样，不会因为一个请求需要延迟而让后面的代码进行等待(这是我比较浅显庸俗的理解，要是理解得不对望见谅，欢迎纠正！(′▽`〃))。所以，Actions 是可以异步改变state状态的，Mutations 一定是同步改变状态的，废话太多了，直接上代码吧！&#8195;&#8195;首先在store.js中actions添加方法，这里先说明一下，Actions里的方法是可以调用Mutations里的方法的，下面把各类情况都列一下：1234567891011actions: &#123; add_100 (&#123; state &#125;) &#123; state.count += 100 // 此方法就是将count加100, &#123;state&#125;就是仓库的数据源 &#125;, add_call (context) &#123; context.commit('add') // 此方法调用了Mutations中的add方法，content是上下文，其实就是这个store &#125;, reduce_call (&#123; commit &#125;) &#123; commit('reduce') // 此方法调用了Mutations中的reduce方法， &#123;commit&#125;是直接把commit对象传递归来 &#125;&#125;&#8195;&#8195;上面三个方法都是actions里声明的方法，对应参数的解释都写在注释里面了。然后在事件中引用，这个时候不能用$store.commit(String methos) 来引用 actions 方法，因为这个引用方式只适用于 mutations ，引用 actions 需要这样$store.dispatch(String methos)来引入：123&lt;button @click="$store.dispatch('add_100')"&gt;对count进行+100操作&lt;/button&gt;&lt;button @click="$store.dispatch('add_call')"&gt;对count进行+1操作&lt;/button&gt;&lt;button @click="$store.dispatch('reduce_call')"&gt;对count进行-1操作&lt;/button&gt;&#8195;&#8195;既然 State 和 Mutations 都有辅助函数，那 Action 也一定有，毕竟都是 Vuex 的“孩子”，手心手背都是肉！！！同样的，我们需要先引入辅助函数mapAction：1import &#123;mapActions&#125; from 'vuex'然后同样在 Vue 的 methods 方法集属性里添加辅助函数：123methods: &#123; ...mapActions(['add_100', 'add_call', 'reduce_call'])&#125;&#8195;&#8195;最后在Html部分修改一下button的click指向：123&lt;button @click="add_100"&gt;对count进行+100操作&lt;/button&gt;&lt;button @click="add_call"&gt;对count进行+1操作&lt;/button&gt;&lt;button @click="reduce_call"&gt;对count进行-1操作&lt;/button&gt;&#8195;&#8195;但是现在我们在 actions 里写的都是同步的代码请求，效果和 mutation 一样，那下面我们加点东西，让 actions 展现自己存在的价值，我们在修改一下action的方法：12345678910111213actions: &#123; add_100 (&#123; state &#125;) &#123; state.count += 100 // 此方法就是将count加100, &#123;state&#125;就是仓库的数据源 &#125;, add_call (context) &#123; context.commit('add') // 此方法调用了Mutations中的add方法，content是上下文，其实就是这个store &#125;, reduce_call (&#123; commit &#125;) &#123; // commit('reduce') // 此方法调用了Mutations中的reduce方法， &#123;commit&#125;是直接把commit对象传递归来 setTimeout(() =&gt; &#123; commit('reduce') &#125;, 3000) // 因为没有现成的移步请求，测试移步最好的方法就是加定时器喽 console.log('这一行代码比上面的reduce早执行，reduce会在3秒后执行') &#125;&#125;&#8195;&#8195;具体效果就不截图了，自行运行一下项目，打开控制台你就知道发生了什么。关于 Getter 和 Model&#8195;&#8195;Vuex 的简单使用方法就这么多，其实还有getter、model两个属性没有将介绍，简单说一下吧！&#8195;&#8195;getter其实就是设置 state 里的一些状态值在每次进行改变的时候都先对这个值进行一些操作的这样一个属性，比如可以在 store 中设置添加getter对count在每次进行加减时进行×10的操作，这个功能主要起到一些过滤作用。&#8195;&#8195;而model呢，就是将上述所讲的state、mutations、actions、getter几个属性进行整合分类，主要用途就是在你的项目后期变得越来越大的时候，那么store里的状态值啊、方法啊都会变得越来越多，而有的状态值都是针对某些特定的业务需求的，那么就可以用model来进行分类，一个model里包含了state、mutations、actions、getter，而store仍然只能有一个，它就可以包含多个model。&#8195;&#8195;这两个属性先这样简单介绍一下吧，后续我再补上其详细用法，见谅！&#8195;&#8195;来首音乐休息一下吧！var ap=new APlayer({element:document.getElementById("aplayer-cUQpLnBo"),narrow:!1,autoplay:!1,showlrc:3,music:{title:"起风了",author:"买辣椒也用券",url:"https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/audio/%E8%B5%B7%E9%A3%8E%E4%BA%86.mp3",pic:"https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/poster/%E8%B5%B7%E9%A3%8E%E4%BA%86.jpg",lrc:"https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/lyric/%E8%B5%B7%E9%A3%8E%E4%BA%86%20-%20%E4%B9%B0%E8%BE%A3%E6%A4%92%E4%B9%9F%E7%94%A8%E5%88%B8.lrc"}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo音乐插件 hexo-tag-aplayer 的坑]]></title>
    <url>%2FHexo%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6%20hexo-tag-aplayer%20%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;博客相信现在好多技术大牛都有，例如博客园、简书、CSDN之类的大型博客网站，但是局限性蛮大的，只能按照网站的规则去写写文章，留个言什么的，要是个人博客就不一样了，可以根据自己的需要去添加任何功能。&#8195;&#8195;在搭建博客时用到hexo-tag-aplayer这样一个音乐插件，可以很优雅地在H5页面中播放音乐，可以算是Hexo框架中最好的音乐插件之一了，体验效果请试听。。。var ap=new APlayer({element:document.getElementById("aplayer-QKPmmLin"),narrow:!1,autoplay:!1,showlrc:3,music:{title:"一个人的北京",author:"海鸣威",url:"https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/audio/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.mp3",pic:"https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/poster/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.jpg",lrc:"https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/lyric/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC%20-%20%E6%B5%B7%E9%B8%A3%E5%A8%81.lrc"}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)问题描述&#8195;&#8195;使用hexo-tag-aplayer插件的时候，可以将音乐文件、封面图片放在项目的资源文件夹中，直接引用就行，但是时间长了，项目中的资源文件夹会非常大，严重影响项目的部署效果。插件可以直接引用网络路径，这样就可以将文件上传到阿里云、七牛云之类的对象存储服务器(这里说点废话，阿里云对象存储需要money，但是不是很贵，七牛云普通用户就可以享受10G的免费存储空间，其他的云平台自己百度)，然后复制粘贴文件URL就可以实现上面音乐播放器的效果。&#8195;&#8195;问题在这，这个插件也可以设定歌曲的歌词，不过也需要引用歌词文件(一般都是lrc格式，也有txt格式等)，同样将歌词文件上传到相应的云平台上,然后拷贝文件路径粘贴一下，部署，发现歌词没显示出来，F12查看控制台，发现说歌词文件访问不了，存在跨域问题，绝了都！！！&#8195;&#8195;为啥封面图片就可以直接配置网络路径访问呢？开始没想到在云平台进行相应的设置，光在自己博客项目一顿倒腾，没整出来，简直了。&#8195;&#8195;后来直接上插件的GitHub开源项目的issues讨论里面溜达一圈，希望能找到一点线索。果然，不管是我一个人有这样的问题，插件目前的维护者给出的解决办法如下：&#8195;&#8195;跨域限制是浏览器为了防止诸如 CSRF 等攻击所采取的安全措施，如果歌词文件是遇到跨域问题，请考虑将歌词文件放到同源网站（如 https://www.xxwhite.com ）再进行请求，或者如果有歌词文件所在服务器的权限，请在歌词文件资源返回的 HTTP 头中添加 Access-Control-Allow-Origin 字段。&#8195;&#8195;绝了都，歌词为什么就不能像封面图片直接通过访问资源拿到呢？就不能弄得和封面图片一个吗？算了，小白的我不懂大神的难处，只能照着维护者的意思解决喽。解决办法&#8195;&#8195;到云平台将资源文件设置一下 HTTP 头，解决跨域问题，因为博主用的是阿里云，所以以下内容暂针对阿里云OSS对象存储进行解决跨域问题。&#8195;&#8195;在阿里云控制台中选择“对象存储OSS”菜单，在选择你存放资源的那个Bucket(什么是Bucket，就是一个自己添加的存储空间)，然后选择“基础设置” – &gt; “跨域设置”。&#8195;&#8195;然后点击“创建规则”，接着照着我的填写和勾选。&#8195;&#8195;接着点击确定，再回去你的博客看看歌词是不是出来了。&#8195;&#8195;还有一个小插曲，如果个人博客的域名用的是HTTPS头，那么所引用的资源文件也必须要是HTTPS头的，阿里云OSS对象存储可以直接将文件设置HTTPS头，其他的云平台自行设置，后续有机会可以再续上七牛云的设置方法。其实这也不是什么很难的问题，就是自己遇上了，记录一下。]]></content>
      <categories>
        <category>前端</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-tag-aplayer</tag>
        <tag>音乐插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli项目中rem布局的配置]]></title>
    <url>%2Fvue-cli%E9%A1%B9%E7%9B%AE%E4%B8%ADrem%E5%B8%83%E5%B1%80%E7%9A%84%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[今天在用 Vue 重构一个项目的遇到一个css单位问题——rem布局。rem自适应布局是前端在移动端页面中常用的手法，这次重构的项目就是一个移动端H5项目，用vue搭建首页后发现css中同样用的是rem单位，在Chrome中调试时却发现被定义元素的宽高明显不一样。rem简单描述&#8195;&#8195;rem和px的比例其实是可以自行去设置相应的比例，并不是固定的一个值。我们往往直接在H5中使用rem去定义元素的属性值，所显示rem和px比例值都是浏览器的默认比例1rem = 16px，所以如果给一个div定义宽度width: 1rem，那么在浏览器默认是width: 16px。&#8195;&#8195;是不是很好奇为什么1rem = 16px，这样太不好计算了，如果我需要一个元素的宽度是100px，如果要用rem去定义的话就是100px / 16 = 6.25rem，不仅不是整数，而且计算也麻烦，所以我们该怎么办才能让rem被使用的更加顺手呢？前面说过，rem和px是可以自行去设置比例，，如果在H5页面的html标签里设置font-size: 62.5%，那么相当于此页面中默认字体的大小是10px，也就是1rem = 10px，好算又好看。vue中的解决办法&#8195;&#8195;既然在Html的页面的html标签中直接设置font-size就可以改变rem和px的比例，那么是不是直接在Vue项目中的index.html入口文件的中也设置一下font-size呢？当然不是这样！在实际使用中有很多不同的移动端设置，他们相对应的font-size也当然要不一样，所以需要自适应配置rem。&#8195;&#8195;办法就是使用js去改变比例，通过js去操作入口文件的 Html DOM 去改变font-size的值，js内容的写法有很多，这里贴出所使用的代码。12345678910111213// iphone6 为基准 rem 布局 ，iphone6 的宽高是375*667(function (doc, win) &#123; var docEl = doc.documentElement var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize' var recalc = function () &#123; var clientWidth = docEl.clientWidth if (!clientWidth) return docEl.style.fontSize = (clientWidth / 37.5) + 'px' &#125; if (!doc.addEventListener) return win.addEventListener(resizeEvt, recalc, false) doc.addEventListener('DOMContentLoaded', recalc, false)&#125;)(document, window)&#8195;&#8195;这里说一下实现步骤，先在Vue项目的src目录下新建一个comment文件夹，然后再文件夹内新建rem.js，将上面代码复制进去，保存。最后在src目录下的main.js文件中添加import &#39;../comment/rem&#39;，完事。遇到的坑坑1&#8195;&#8195;在找到解决办法后还遇到一个“不算问题”的问题，那就是谷歌浏览器Chrome给我造成的问题。通过上述办法设置rem和px比例为1rem = 10px,然后设置一个div元素的高度为7rem，然后在调试器中却发现一直是84px，按照比例计算应该是70px，找了好久找不出问题原因。后来突然灵光一闪，想起来谷歌浏览器的默认字体大小最小为12px，无论怎么设置字体大小都不能小于12px，即使你设置1px，最后也会发现是12px，所以谷歌浏览器的rem和px比例最小是1rem = 12px。最后只能修改比例，改成1rem = 20px。坑2&#8195;&#8195;虽然设置好了rem比例，但是移动端的设备也有个别型号比较麻烦的，就像iPad Pro(1024 × 1366)，或者要是把移动端项目放在PC端上，会发现设备宽度越宽，那页面的元素也会按照比例被放大很多，导致视觉体验效果特别不好，所以我们的js代码仍需要优化，需要进行最大宽度判断。完整代码如下：1234567891011121314151617// iphone6 为基准 rem 布局 ，iphone6 的宽高是375*667(function (doc, win) &#123; var docEl = doc.documentElement var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize' var recalc = function () &#123; var clientWidth = docEl.clientWidth if (!clientWidth) return if (clientWidth &gt; 768) &#123; docEl.style.fontSize = '40px' &#125; else &#123; docEl.style.fontSize = 1 * (clientWidth / 18.75) + 'px' &#125; &#125; if (!doc.addEventListener) return win.addEventListener(resizeEvt, recalc, false) doc.addEventListener('DOMContentLoaded', recalc, false)&#125;)(document, window)]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目前流行的前后端框架技术列举]]></title>
    <url>%2F%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E5%88%97%E4%B8%BE.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;这是本博客的第一篇文章，不知道是该写点什么东西才好，正好自己平时比较喜欢浏览一些公总号上的技术文章，这两天看到几篇对目前比较前沿的、使用人数较多的(流行的)前后端技术，这里我整合记录一下，算是给自己往后的学习列一个大纲。后端&#8195;&#8195;Java目前是业内使用的编程语言中占据最高的地位，毕业生初入社会要是从事后端工作的话，大多都会投递从事Java开发的简历，所以Java这门编程语言，应该是很多后端程序员必备的基础技能，甚至可以说是“吃饭的家伙”。&#8195;&#8195;即使目前自己从事前端开发工作，但也会学习后端基础，多了解了解总有好处。这里列举一下对博主而言目前比较重要的一些Java Web框架，并且都上网查了每个框架的官网和github上的源码，可能没有太大的必要，但是还是记录一下吧。Spring&#8195;&#8195;Spring这个词相信只要是程序员，就算不知道是干吗的，但至少也听说过。Spring是一个开放源代码的设计层面框架，它解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用(描述得有点官方化，摘自百度百科)。&#8195;&#8195;说点大家都听得懂得吧，Spring是Java后端框架里最强大的，从字面上理解是“春天”的意思，那就是我们程序员的春天，自然是最牛的。Spring的优点就不一一列举了，大多情况下我也只是会用，不太理解框架的底层原理，真是惭愧，这点的确是需要进步滴。Spring 有 IOC 和 AOP 两大利器，大大简化了软件开发复杂性。总而言之，Spring就是很好，让Java开发更加简单。官网：https://spring.io/projects/spring-framework源码：https://github.com/spring-projects/spring-frameworkSpring MVC&#8195;&#8195;Spring MVC就是一个MVC框架，它类似于Struts的一个MVC开框架，其实都是属于Spring，Spring MVC需要有Spring的架包作为支撑才能跑起来，是Spring项目的重要成员，主要也是也是让Java开发变得更加简答。官网：https://spring.io/projects/spring-framework源码：https://github.com/spring-projects/spring-frameworkSpring Boot&#8195;&#8195;Spring Boot 是 Spring 开源组织下的一个子项目，个人感觉它最大的优点就是简化了需要配置文件，把Spring有关的各种xml配置文件都压缩成一个，让Spring开始使用起来更加简答。再有一个特点就是，这个东东居然自己集成了Tomcat，也就是它内置Tomcat启动。官网：https://spring.io/projects/spring-boot源码：https://github.com/spring-projects/spring-bootSpring Cloud&#8195;&#8195;Spring Cloud 是一系列框架的有序集合，是目前最火热的微服务框架首选，它利用Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署(摘自百度百科主要博主也没用这个框架，不是很了解，后续可以一起学习交流)。官网：http://projects.spring.io/spring-cloud/源码：https://github.com/spring-cloudMybatis/ iBatis&#8195;&#8195;Mybatis是一款持久层(简单理解持久层就是，直接操作数据库那一层)框架，它支持定制化 SQL、存储过程以及高级映射。这个框架就是让我们在进行Java开发时，在对数据进行增删改查时显得更加优雅、高效。官网：http://www.mybatis.org/mybatis-3/源码：https://github.com/mybatisDubbo&#8195;&#8195;很早就知道分布式服务这个概念，一直也很想学习了解一下。Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案。RPC 指的是远程调用协议，也就是说两个服务器交互数据。它能干吗？简单来说，用户发送的请求转交给 Nginx，然后 Nginx 决定将请求发送那个服务器（此处为 Tomcat），然后 Tomcat 将请求发送给 Dubbo，由它来决定继续调用哪个 service 层去数据库读取数据(摘自简书博客文章)。官网：http://www.mybatis.org/mybatis-3/源码：https://github.com/mybatisNetty&#8195;&#8195;Netty 是由 JBOSS 提供的一个开源的、异步的、基于事件驱动的网络通信框架，用 Netty 可以快速开发高性能、高可靠性的网络服务器和客户端程序，Netty 简化了网络应用的编程开发过程，使开发网络编程变得异常简单。官网：https://netty.io/源码：https://github.com/netty/nettyShiro&#8195;&#8195;Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。官网：http://shiro.apache.org/源码：https://github.com/apache/shiroEhcache&#8195;&#8195;EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的CacheProvider。它使用的是 JVM 的堆内存，超过内存可以设置缓存到磁盘，企业版的可以使用 JVM 堆外的物理内存。官网：http://www.ehcache.org/源码：https://github.com/ehcache/ehcache3JUnit&#8195;&#8195;JUnit 是一个 Java 语言的单元测试框架，绝大多数 Java 的开发环境都已经集成了 JUnit 作为其单元测试的工具。官网：https://junit.org源码：https://github.com/junit-team/Log4j&#8195;&#8195;Log4j 是 Apache 的一个开源日志框架，通过 Log4j 我们可以将程序中的日志信息输出到控制台、文件等来记录日志。作为一个最老牌的日志框架，它现在的主流版本是 Log4j2。Log4j2是重新架构的一款日志框架，抛弃了之前 Log4j 的不足，以及吸取了优秀日志框架 Logback 的设计。官网：https://logging.apache.org/log4j/2.x/源码：https://logging.apache.org/log4j/2.x/source-repository.html前端&#8195;&#8195;前端，是近几年火起来的岗位，听说在以前，并没有“前端”这个岗位称呼，不过好像有叫网页制作的岗位，应该就是现在前端的前身了，工作内容就是画画网页页面，实现页面交互功能，好像并不是大多程序员的首选岗位。现在不一样了，前端近几年的技术栈更新的特别快，尤其是Node.js，那更是让我喜欢。下面同样也列出一些前端上的技术框架。NodeJs&#8195;&#8195;Node.js是一个Javascript运行环境，是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。简单的说 Node.js 就是运行在服务端的 JavaScript。以上从百度百科和菜鸟教程借鉴过来混合描述了一下Node.js。&#8195;&#8195;用自己的话简单描述一下 Node.js 吧。首先我们要确定一个正确的概念，Node.js不是JavaScript框架，应该算一个开发环境，这样说吧，安装了Node.js，就可以通过命令行下载目前网络上各种组件依赖，从而搭建起来前端项目。Node本身也算是一种后台语言，也就是用JS语言实现后台功能，大多是前端工程师在用。官网：https://nodejs.org/en/源码：https://github.com/nodejs/node/tree/master/lib/internalVue&#8195;&#8195;Vue是目前国内比较火的前段框架，是一套构建用户界面的渐进式框架。Vue是我毕业实习所学习的第一个前端框架，上手不难，看着官方文档学习能很快掌握用法。先说说Vue最大的优点就是，相比传统的用Js或者jQuery去操作Dom来进行页面数据的渲染，Vue能直接将数据和Html元素进行连接，实时更新，减少了前端的工作量，光说不如直接去实践。官网：https://cn.vuejs.org/源码：https://github.com/vuejs/vueReact&#8195;&#8195;StateOfJS 表示，React 拥有JavaScript框架里最大的市场份额，大概占比64.8%。只不过这个框架我没用过，既然这么多人在用，应该也是一个很值得去学习的。官网：https://reactjs.org/源码：https://github.com/facebook/react/Redux&#8195;&#8195;Redux 是使用最广泛的工具，82％ 的满意率也证明了它的成熟程度。这是JavaScript的数据层工具，之前也没有用过，先记录一下，后续有机会可以学习。官网：https://www.redux.org.cn/源码：https://github.com/reduxjs/reduxExpress&#8195;&#8195;在搭建此博客之前，我并不知道有Hexo这样一个能够快速构建个人博客的前段框架，打算想自己写一个，再一次偶然的机会，我在一些技术贴上看到了一个JavaScript的后台框架Express，能够用JS语言搭建基于Node.js的后端，这让我眼前一亮，既然目前是前段开发，就心想直接用JS去做一整套包括前后端的个人博客网站吧，而且能根据我自己的需求去设计自己想要的功能。&#8195;&#8195;说做就做了，我一边学习一边实践，陆陆续续经过两三个月实现了一个简单的个人博客。不多说了，后续有时间我将搭建过程写出来分享给大家。官网：http://www.expressjs.com.cn/源码：https://github.com/expressjs/expressMocha&#8195;&#8195;调查显示，Mocha 仍然是最常用的单元测试框架。它已经存在了很长一段时间，拥有最大的生态系统。Electron&#8195;&#8195;Electron是使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用官网：https://electronjs.org/源码：https://github.com/electron其他的&#8195;&#8195;以上就是自己搜集的前后端技术框架，但是目前技术更新太快，可能有其他更加好更加便捷的框架，所以本文内容仅供参考。&#8195;&#8195;除了编程语言、框架技术，我们还需要了解一下其他的开发有关的东西，如编译器、服务器、版本管理工具等等。。。&#8195;&#8195;Java开发工具推荐使用 IntelliJ IDEA ，用过的朋友朋友当然最好，没有用过朋友的建议早点接触使用，目前对于 Java 开发来说，个人感觉这是最好用的编译器了。前端的话推荐使用 Visual Studio Code，这也是我自己才开始使用的前段编辑器，之前也听过，一直觉得应该和 Sublime 差不多，但是一次偶然的机会下载使用了一次，便发现没有比这更适合我的前端开发工具了。&#8195;&#8195;服务器，我目前一直使用的是阿里云，阿里云有一个云翼计划，24岁以下用户自动默认为学生用户，可以购买一年114.00元的服务器(1核2G，带宽1M，40G空间，购买链接)，个人觉得相当实惠(声明，没有给阿里云打广告，只是因为真的喜欢阿里云产品)。服务器系统直接 Linux 吧，因为 WinService 和我们所使用的 Windows 没什么操作上的区别，对自己的提升不大。&#8195;&#8195;版本管理工具就 Git 喽，这些网上教程都很多，SVN也可以试着了解一下，可能有些公司内部会有用到。&#8195;&#8195;学无止境，IT 行业更是如此。]]></content>
      <categories>
        <category>技术列举</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
