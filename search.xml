<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot 项目（二）整合Druid数据库连接池]]></title>
    <url>%2FSpring%20Boot%20%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B4%E5%90%88Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;Druid 是一个数据连接池，是阿里巴巴的一个开源项目，整个项目由数据库连接池、插件框架和SQL解析器组成。同名还有一个大数据分析系统，也叫Druid，需要区分一下。&#8195;&#8195;本文记录 Spring Boot 项目整合 Druid 数据库连接池。添加依赖&#8195;&#8195;在 Spring Boot 项目中的maven配置文件中引入依赖：123456&lt;!-- 数据库连接池用的是阿里巴巴的druid，结合了c3p0、dbcp等其他连接池的优点 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;配置文件&#8195;&#8195;1、在项目配置文件application.yml(或者application.properties)中配置连接池：123456789101112131415161718192021spring: datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://yourIP:yourPort/demo?useUnicode=true&amp;amp;characterEncoding=UTF-8 username: yourUsername password: yourPassword driver-class-name: com.mysql.jdbc.Driver connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 minIdle: 5 validationQuery: SELECT 1 FROM DUAL initialSize: 5 #初始化数量 maxWait: 60000 #最大连接等待超时时间 poolPreparedStatements: true #打开PSCache maxPoolPreparedStatementPerConnectionSize: 20 #并且指定每个连接PSCache的大小 testOnBorrow: false testWhileIdle: true minEvictableIdleTimeMillis: 300000 timeBetweenEvictionRunsMillis: 60000 testOnReturn: false maxActive: 20 #最大活跃数 filters: stat,wall&#8195;&#8195;2、在 Spring Boot 的配置文件夹中添加DruidConfig.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.aifeier.demo.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import javax.sql.DataSource;import java.sql.SQLException;@Data@Configuration@ConfigurationProperties(prefix = "spring.datasource")public class DruidConfig &#123; private String type; private String url; private String username; private String password; private String driverClassName; private String connectionProperties; private int minIdle; private String validationQuery; private int initialSize; private int maxWait; private boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private boolean testOnBorrow; private boolean testWhileIdle; private int minEvictableIdleTimeMillis; private int timeBetweenEvictionRunsMillis; private boolean testOnReturn; private int maxActive; private String filters; @Bean //声明其为Bean实例 @Primary //在同样的DataSource中，首先使用被标注的DataSource public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setDriverClassName(driverClassName); dataSource.setDbType(type); dataSource.setMinIdle(minIdle); dataSource.setValidationQuery(validationQuery); dataSource.setInitialSize(initialSize); dataSource.setMaxWait(maxWait); dataSource.setPoolPreparedStatements(poolPreparedStatements); dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setTimeBetweenConnectErrorMillis(timeBetweenEvictionRunsMillis); dataSource.setTestOnReturn(testOnReturn); dataSource.setMaxActive(maxActive); try &#123; dataSource.setFilters(filters); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; dataSource.setConnectionProperties(connectionProperties); return dataSource; &#125; /** * 注册一个StatViewServlet * * @return */ @Bean public ServletRegistrationBean DruidStatViewServle() &#123; // org.springframework.boot.context.embedded.ServletRegistrationBean提供类的进行注册. ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); // 添加初始化参数：initParams // 白名单： servletRegistrationBean.addInitParameter("allow", "127.0.0.1"); // IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not // permitted to view this page. servletRegistrationBean.addInitParameter("deny", "192.168.1.73"); // 登录查看信息的账号密码. servletRegistrationBean.addInitParameter("loginUsername", "admin"); servletRegistrationBean.addInitParameter("loginPassword", "123456"); // 是否能够重置数据. servletRegistrationBean.addInitParameter("resetEnable", "false"); return servletRegistrationBean; &#125; /** * 注册一个：filterRegistrationBean * * @return */ @Bean public FilterRegistrationBean druidStatFilter() &#123; //创建过滤器 FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); //设置过滤器过滤路径 filterRegistrationBean.addUrlPatterns("/*"); //忽略过滤的形式 filterRegistrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"); return filterRegistrationBean; &#125;&#125;&#8195;&#8195;到这Druid的配置算是完了，要是想进入Druid后台查看监控数据，可以启动项目后在浏览器里输入网址打开 http://127.0.0.1:8080/druid/ 进行访问，登录名和密码在上面的DruidConfig.java中进行配置：123// 登录查看信息的账号密码.servletRegistrationBean.addInitParameter("loginUsername", "admin");servletRegistrationBean.addInitParameter("loginPassword", "123456");小坑&#8195;&#8195;Spring Boot 整合 Mybatis-Plus 和 Druid时，在配置Mybatis-plus时需要获取DataSource的Bean实例，MybatisPlusConfig.java 的配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Autowiredprivate DataSource dataSource;@Autowiredprivate MybatisProperties properties;@Autowiredprivate ResourceLoader resourceLoader = new DefaultResourceLoader();@Autowired(required = false)private Interceptor[] interceptors;@Autowired(required = false)private DatabaseIdProvider databaseIdProvider;/*** 这里全部使用mybatis-autoconfigure 已经自动加载的资源。不手动指定* 配置文件和mybatis-boot的配置文件同步** @return*/@Beanpublic MybatisSqlSessionFactoryBean mybatisSqlSessionFactoryBean() &#123; MybatisSqlSessionFactoryBean mybatisPlus = new MybatisSqlSessionFactoryBean(); System.out.println("*************" + dataSource); mybatisPlus.setDataSource(dataSource); mybatisPlus.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) &#123; mybatisPlus.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); &#125; mybatisPlus.setConfiguration(properties.getConfiguration()); if (!ObjectUtils.isEmpty(this.interceptors)) &#123; mybatisPlus.setPlugins(this.interceptors); &#125; MybatisConfiguration mc = new MybatisConfiguration(); mc.setDefaultScriptingLanguage(MybatisXMLLanguageDriver.class); mybatisPlus.setConfiguration(mc); if (this.databaseIdProvider != null) &#123; mybatisPlus.setDatabaseIdProvider(this.databaseIdProvider); &#125; if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123; mybatisPlus.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); &#125; if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123; mybatisPlus.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); &#125; if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123; mybatisPlus.setMapperLocations(this.properties.resolveMapperLocations()); &#125; return mybatisPlus;&#125;&#8195;&#8195;而这个Bean实例就是Druid配置中的DataSource Bean实例，如下（完整代码看上面）：1234567891011121314151617181920212223242526272829@Bean //声明其为Bean实例@Primary //在同样的DataSource中，首先使用被标注的DataSourcepublic DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setDriverClassName(driverClassName); dataSource.setDbType(type); dataSource.setMinIdle(minIdle); dataSource.setValidationQuery(validationQuery); dataSource.setInitialSize(initialSize); dataSource.setMaxWait(maxWait); dataSource.setPoolPreparedStatements(poolPreparedStatements); dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setTimeBetweenConnectErrorMillis(timeBetweenEvictionRunsMillis); dataSource.setTestOnReturn(testOnReturn); dataSource.setMaxActive(maxActive); try &#123; dataSource.setFilters(filters); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; dataSource.setConnectionProperties(connectionProperties); return dataSource;&#125;&#8195;&#8195;项目会报错，提示出现dbType不支持：1Invocation of init method failed; nested exception is com.baomidou.mybatisplus.exceptions.MybatisPlusException: Error: GlobalConfigUtils setMetaData Fail ! Cause:java.lang.IllegalStateException: dbType not support : com.alibaba.druid.pool.DruidDataSource&#8195;&#8195;多番测试，是配置文件中 Druid 的 dataSource 属性中的 filters 属性出了问题，Druid 官方文档表明 filters 可以设置多个值，用逗号分开，按照要求写在MybatisPlusConfig中就是会报错，所以干脆就不在DruidConfig中将 filters Set到 dataSource 实例中，对Druid也不会有什么影响，毕竟配置文件中已经设置了自己想要的值。所以，在DruidConfig.java中将以下代码进行注释：12345// try &#123;// dataSource.setFilters(filters);// &#125; catch (SQLException e) &#123;// System.err.println("druid configuration initialization filter: "+ e);// &#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目（一）整合 Mybatis Plus]]></title>
    <url>%2FSpring%20Boot%20%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B4%E5%90%88%20Mybatis%20Plus.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;Spring 项目结合 Spring Boot 框架来搭建后台是目前比较主流的技术，不仅简化了配置文件，也让 Spring 使用起来更加方便。&#8195;&#8195;Spring Boot 整合 MyBatis-Plus （基于Mybatis的第三方持久层框架）让数据操作更加简单、优雅。 简单介绍一下&#8195;&#8195;先给出官方的介绍：MyBatis-Plus（简称 MP）是一个 MyBatis(http://www.mybatis.org/mybatis-3/) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。&#8195;&#8195;Mybatis-Plus 主要也是为了简化 Mybatis 的开发，比如单纯使用 Mybatis 去进行数据增删改查甚至更复杂的数据操作需要创建很多xml文件，写很多 SQL 代码，如果项目小点还好，要是中大型项目，这么多的 xml 以及密密麻麻的 SQL 代码维护起来着实让人头疼，我自己的大学毕业设计就是一个很好的例子。而 Mybatis-Plus 呢，将很多 CRUD 数据操作方法进行整合封装，在service、servicImpl、mapper、xml等方面都大大减少了代码量，还有 Mybatis-Plus 的代码生成器也设计得比较好，几乎不用我们手动去创建刚刚说的这些文件包括Entity实体类。Mybatis-Plus 还有热加载、代码生成、分页、性能分析等功能一应俱全。&#8195;&#8195;不说了，能动手就别唠叨！ 添加依赖&#8195;&#8195;目前 Mybatis-Plus 已经到了3.0.6版本，官方指明MP(Mybatis-Plus缩写)3.0要求 JDK 版本要在8以上。&#8195;&#8195;首先需要创建Spring Boot 项目，IDEA 已经集成了 Spring Initializr 工具，可以快速创建 Spring Boot 项目，默认已经引入了Spring Boot Staeter 父工程，要不是快速创建的项目，需要先引入 Spring Boot Staeter 父工程：123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; &#8195;&#8195;然后引入 spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、lombok、mysql、druid 依赖：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;!-- Spring 核心模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring 测试模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 如果需要可以引入Spring Web 模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Lombok可以减少很多重复代码的书写，比如说getter/setter/toString等方法的编写，还有日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- Mybatis-Plus 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql 依赖，maven库有更高版本如8.0，这里用5.1.22 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池用的是阿里巴巴的druid，结合了c3p0、dbcp等其他连接池的优点 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置&#8195;&#8195;项目文件结构目录如下：&#8195;&#8195;快速构建的Spring Boot的配置文件一般是application.properties的properties格式文件，可以自行修改文件后缀为yml，不改也可以。在application.yml中配置如下：123456789101112131415161718192021spring: datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://yourIP:yourPort/yourDatabase username: yourUsername password: yourPassword driver-class-name: com.mysql.jdbc.Driver connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 minIdle: 5 validationQuery: SELECT 1 FROM DUAL initialSize: 5 maxWait: 60000 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 testOnBorrow: false testWhileIdle: true minEvictableIdleTimeMillis: 300000 timeBetweenEvictionRunsMillis: 60000 testOnReturn: false maxActive: 20 filters: stat,wall ##&#8195;&#8195;用本地Mysql创建本地连接，再新建一个数据库(名称为demo)，然后新建一张数据库(名称为users)，添加字段如下：1234567CREATE TABLE `users` ( `id` int(10) NOT NULL AUTO_INCREMENT, `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `age` int(1) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; 创建实体类、service、mapper&#8195;&#8195;编写实体类 UserEntity.java，如下：12345678910111213package com.aifeier.demo.entity;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@TableName("users")@Datapublic class UserEntity &#123; private long id; private String username; private String sex; private Integer age;&#125; &#8195;&#8195;编写 IUserService.java 接口如下：12345678package com.aifeier.demo.service;import com.aifeier.demo.entity.UserEntity;import com.baomidou.mybatisplus.extension.service.IService;public interface IUserService extends IService&lt;UserEntity&gt; &#123;&#125; &#8195;&#8195;编写 UserServiceImpl.java 实现类接口如下：12345678910111213package com.aifeier.demo.service.impl;import com.aifeier.demo.entity.UserEntity;import com.aifeier.demo.mapper.UserMapper;import com.aifeier.demo.service.IUserService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, UserEntity&gt; implements IUserService &#123;&#125; &#8195;&#8195;编写 UserMapper.java 接口如下：123456789101112package com.aifeier.demo.mapper;import com.aifeier.demo.entity.UserEntity;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;@Mapper@Repositorypublic interface UserMapper extends BaseMapper&lt;UserEntity&gt; &#123;&#125; 开始使用&#8195;&#8195;接下来直接在test测试单元中直接进行测试，在 DemoApplicationTests.java 中添加如下：123456789101112131415161718192021222324252627package com.aifeier.demo;import com.aifeier.demo.entity.UserEntity;import com.aifeier.demo.service.IUserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private IUserService iUserService; @Test public void contextLoads() &#123; UserEntity user = new UserEntity(); user.setUsername("埃菲尔"); user.setSex("男"); user.setAge(18); boolean flag = iUserService.save(user); System.out.println(flag ? "添加成功" : "添加失败"); &#125;&#125; &#8195;&#8195;运行单元测试就能看到控制台输出“添加成功”。 自行编写SQL&#8195;&#8195;开发中当然光靠Mybatis-Plus 中封装好的 CRUD 方法是不够的，有时有一些复杂需求需要自行编写SQL来获取数据，比如有时候需要在插入一条记录后同时返回插入记录的id主键值，那下面就实现这一需求。&#8195;&#8195;首先在配置文件目录中resources中新建mybatis文件夹，在mybatis文件夹里新建mapper文件夹，在mapper文件夹中新建UserMapper.xml，内容如下：1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.aifeier.demo.mapper.UserMapper"&gt; &lt;insert id="insertResultId" parameterType="UserEntity" keyProperty="id" useGeneratedKeys="true"&gt; INSERT INTO users(username,sex,age) VALUES(#&#123;username&#125;,#&#123;sex&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; &#8195;&#8195;文件目录在上面截图上可见。在application.yml中配置mybatis-plus,如下：1234567891011121314151617181920212223#mybatismybatis-plus: mapper-locations: classpath:/mybatis/mapper/*.xml typeAliasesPackage: com.aifeier.demo.entity #实体扫描，多个package用逗号或者分号分隔 config-locations: classpath:/mybatis/mybatis-config.xml global-config: #刷新mapper 调试神器 db-config: id-type: id_worker #主键类型 0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID UUID"; field-strategy: not_empty #字段策略 0:"忽略判断",1:"非 NULL 判断"),2:"非空判断" column-underline: true #驼峰下划线转换 #capital-mode: true #数据库大写下划线转换 logic-delete-value: Y #逻辑删除配置 logic-not-delete-value: N db-type: mysql refresh: true #自定义填充策略接口实现 #meta-object-handler: com.baomidou.springboot.xxx #自定义SQL注入器 #sql-injector: com.baomidou.springboot.xxx configuration: map-underscore-to-camel-case: true cache-enabled: false &#8195;&#8195;这是声明mapper接口文件所对应的xml位置以及mybatis的一些配置文件。然后修改IUserService.java，如下：123public interface IUserService extends IService&lt;UserEntity&gt; &#123; Integer insertResultId(UserEntity userEntity);&#125; &#8195;&#8195;修改UserServiceImpl.java，如下：123456789@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, UserEntity&gt; implements IUserService &#123; @Autowired private UserMapper userMapper; @Override public Integer insertResultId(UserEntity userEntity) &#123; return userMapper.insertResultId(userEntity); &#125;&#125; &#8195;&#8195;修改UserMapper.java，如下：12345@Mapper@Repositorypublic interface UserMapper extends BaseMapper&lt;UserEntity&gt; &#123; Integer insertResultId(UserEntity userEntity);&#125; &#8195;&#8195;好了，接下来可以再测试类中编写测试代码，如下：1234567891011121314151617public class DemoApplicationTests &#123; @Autowired private IUserService iUserService; @Test public void contextLoads() &#123; UserEntity user = new UserEntity(); user.setUsername("埃菲尔小号"); user.setSex("男"); user.setAge(18);// boolean flag = iUserService.save(user);// System.out.println(flag ? "添加成功" : "添加失败"); iUserService.insertResultId(user); System.out.println("返回的id为：" + user.getId()); &#125;&#125; &#8195;&#8195;完成，运行后能返回插入记录的id。 其他&#8195;&#8195;MybatisPlusConfig.java这个配置文件主要是一些Mybatis-Plus的Bean注入，例如配置 datasource， sqlSessionFactory, transaction manager 等等，晒一下简单的配置，仅供参考：12345678910111213141516171819202122232425262728293031323334353637package com.aifeier.demo.config;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor;import org.mybatis.spring.mapper.MapperScannerConfigurer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MybatisPlusConfig &#123; // 一些配置， 例如，配置 datasource， sqlSessionFactory, transaction manager 等等 /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; /** * 相当于顶部的： * &#123;@code @MapperScan("com.baomidou.cloud.service.*.mapper*")&#125; * 这里可以扩展，比如使用配置文件来配置扫描Mapper的路径 */ @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer(); scannerConfigurer.setBasePackage("com.baomidou.cloud.service.*.mapper*"); return scannerConfigurer; &#125; /** * SQL执行效率插件 */ @Bean public PerformanceInterceptor performanceInterceptor() &#123; return new PerformanceInterceptor(); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Mybatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端 Web 页面调试器 vConsole]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-Web-%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95%E5%99%A8%20vConsole.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;目前移动端Web开发越来越大众普遍，越来越多的前段框架技术都支持移动端兼容和适配，但是不得不说，移动端开发过程中要在手机上调试真的很麻烦，毕竟手机浏览器不能像在 PC 上一样，直接F12就弹出调试器，看到我们再控制台输出的调试信息，有时万般无奈只能使用alert来输出，这真是一个痛点！&#8195;&#8195;腾讯的 vConsole 插件能帮我们解决这个问题！ 下载 安装&#8195;&#8195;首先需要下载 vConsole 的最新版本，或者直接使用 npm 安装：1npm install vconsole 然后复制 dist/vconsole.min.js 到自己的项目中。接着就是将这个插件引入到项目中：&#8195;&#8195;1、使用 script 来直接直接引入 vConsole 模块。单页面应用直接在入口Html文件的 &lt;hean&gt;&lt;/hean&gt; 中引入：123456&lt;head&gt; &lt;script src="path/to/vconsole.min.js"&gt;&lt;/script&gt; &lt;script&gt; var vConsole = new VConsole(); &lt;/script&gt;&lt;/head&gt; &#8195;&#8195;注意：这里的path/to/指的是vconsole.min.js文件的路径，多页面应用要在需要进行调试的每个页面都引入。&#8195;&#8195;2、在入口js文件中使用 require() 引入模块：12var VConsole = require('path/to/vconsole.min.js');var vConsole = new VConsole(); &#8195;&#8195;上面第一行代码只是引入了vConsole的原型，并不会直接在页面插入调试器，需要第二行代码来实例化一个VConsole对象才可以，所以注意，一定要手动进行实例化。&#8195;&#8195;3、如果是在Vue-cli项目里，那先安装vConsole到dependencies中 npm install vconsole ，然后在main.js中引入：1import vConsole from 'vconsole' &#8195;&#8195;按照上面的方法就可以再移动端进行调试了，需要更加详细地了解vConsole，可以去GitHub上看文档。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>调试</tag>
        <tag>vConsole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex 用法总结]]></title>
    <url>%2FVuex-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;很早就开始使用Vue框架了，一直没有用到Vuex，也是最近才开始学着使用Vuex进行全局的状态管理，不得不说，是真的好用。&#8195;&#8195;百度一下就能找到Vuex的官方文档，介绍的很官方化，可就是因为太官方化了，开始学习的时候总是看的似懂非懂，相信很多人也会有这样的感觉，所以博主将Vuex以自己所理解的程度来用自己的话简单记录一下使用方法。对于资深的前端大神们，要是愿意对本文提出意见，当然最好。 简单介绍&#8195;&#8195;先说说Vuex是个什么东西吧。先给大家一个官方文档传送门，官方是这样介绍的：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 &#8195;&#8195;意思就是 Vuex 是一个 Vue 程序的状态管理器，对 Vue 中的一些进行及时更新。我们在项目会使用全局变量来存储一些频繁被使用的信息，比如用户信息、购物车信息等等，这些信息存在全局中随时取用，比起每次去网络请求数据会更加方便、高效。Vue 应用中也会需要用到全局变量来管理一些全局信息，Vuex就是这么一个东东。 不仅如此，Vuex 中管理的状态，一旦改变，可以及时渲染到整个应用中。 进入正题引用根据官方的文档描述，引用方式有两种，一种就是直接引用全局 Script 的文件，但是要注意必须 Vuex 要在 Vue 引用之后再引用，如下：12&lt;script src="/path/to/vue.js"&gt;&lt;/script&gt;&lt;script src="/path/to/vuex.js"&gt;&lt;/script&gt; 注意：上面应用地址/path/to只是样例，真正的地址是 Vue 和 Vuex 的 CDN ，官网上都有。&#8195;&#8195;若是在一个模块化的打包系统中，需要显式地通过 Vue.use() 来安装 Vuex：123import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 一般都会用第二种方法，不过需要先进行 Vue 和 Vuex 的安装。 基本的 Vuex 结构&#8195;&#8195;Vuex 基本结构如下：12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;) &#8195;&#8195;这是Vue-cli 搭建Vue项目时自带就生成Vuex模板(博主这里用的Vue-cli 3.0以上的版本，如果在初始化项目的时候勾选了 Vuex 组件才会有内容如上的store.js文件，位于src目录下)，单词 store 是仓库的意思，很明显，Vuex将存储全局信息的地方称之为仓库。创建好了基本的Vuex 仓库之后需要在 Vue 对象中引入它(注意：一个 Vue 项目应用中只能有一个 Vuex 仓库，足够了！)，具体是在项目入口 main.js 文件中引用，如下：123456789101112import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app') &#8195;&#8195;如果是简单的小型项目，只需要一个store.js即可，毕竟没有太多信息量需要全局管理，若是中大型项目，可以新建一个store文件夹，里面再新建sate.js、mutation.js、actions.js、getter.js分别对应仓库的state、mutations、actions、getter，最后再新建一个index.js，new Vuex.Store()将这四个文件都引用进去即可。&#8195;&#8195;综上所述，Vuex 其实并不是很复杂，就是一个管理 Vue 项目的全局状态信息的管理器，称为store（仓库），主要包含State、Mutation、Action三个核心部分，getter可用可不用看，看自己的项目需要。 Vuex 仓库之 State&#8195;&#8195;Vuex 仓库的核心部分State，官方形容是驱动应用的数据源，我的理解就是这是一个存放数据的地方，就相当于 Vue 中的data属性一样，全部的变量就放在这里，里面存放的数据是项目全局都可访问的状态信息。不多说，直接上代码！&#8195;&#8195;我们在sate里设置一个数据源，就按照官网的例子来吧，设置一个变量叫count，初始值为0，如下：1234567891011export default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;) &#8195;&#8195;然后在新建两个Vue模板，分别为 ATest.vue 和 BTest.vue 就放在view目录下(这是Vue-cli 3.0以上项目才有的目录，就是视图模板的文件夹)，Vue 路由里配置这两个模板组件，怎么配置就不说了，这是 Vue 的知识，不会的请移步Vue菜鸟教程。ATest.vue 和 BTest.vue 都用 来输出全局状态count的值，两个模板的内容都如下：123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是ATest页面&lt;/h1&gt; &lt;h2&gt;全局状态count：&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt; &#8195;&#8195;BTest.vue 中标题就写“这是BTest页面”。然后把项目跑起来，可以看到 ATest 和 BTest 两个视图中都能显示count的值，效果如下:&#8195;&#8195;要是在store仓库中修改state中的count值为10，那么这两个视图中的count也会变成10。但是这样子去写不够优雅，不够漂亮，所以下面介绍三种比较优雅的获取仓库共享值得方法。 赋值方法一：通过computed的计算属性直接赋值&#8195;&#8195;computed是 Vue 的属性，主要用来监控所定义的变量发生变化，变量不需要在data属性中定义，只需要在computed中定义，然后就可以在页面上进行双向数据绑定进行页面渲染，还有就是computed属性可以在变量输出前就对其值进行改变，那我们就用这个方法来将store.js中的state里的值赋值给data。12345computed: &#123; count () &#123; return this.$store.state.count &#125;&#125; 然后将模板中的 $store.state.count 改成 count，再运行项目发现也是能取到值。 赋值方法二：在computed中通过mapState的对象来赋值&#8195;&#8195;mapState是一个 Vuex 的辅助函数，直接上代码。首先我们需要引用mapState。1import &#123;mapState&#125; from 'vuex'; &#8195;&#8195;然后还在computed计算属性里写如下代码：123computed: mapState(&#123; count: state =&gt; state.count // 此处使用EC6的箭头函数语法，理解为传入state对象，返回state.count属性&#125;) &#8195;&#8195;上面用的ES6的箭头函数语法，不了解可以先去百度了解一下，不是很难，就是换了一种函数的写法，显得比较简洁优化、高端大气。 赋值方法三：在computed中通过mapState的数组来赋值&#8195;&#8195;其实3种赋值的方法都是在computed中进行，只是一个比一个更加简洁、优雅。这种方法也是用mapState辅助函数，但是更加简单，如下：1computed: mapState(["count"]) //映射this.count 为 store.state.count &#8195;&#8195;这样也可以拿到state的值，大多都是用这种方法。 Vuex 仓库之 Mutation&#8195;&#8195;State 就像是 Vue 里的data属性一样用来存放变量，那么 Mutation 就好比是 Vue 中的methods一样，用来存放方法，只要是用于更改store仓库里的变量唯一放方法就是用 Mutation。先给出一段官方的介绍：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。&#8195;&#8195;Mutation的使用就是提交一个commit指令来告诉 Vuex 要使用哪个方法来进行对变量进行操作，基本语法是$store.commit(String methos)，先来一个简单的样例代码，在ATest.vue的Html部分加上两个按钮事件，完整代码如下：123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是ATest页面&lt;/h1&gt; &lt;h2&gt;全局状态count：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;br&gt; &lt;button @click="$store.commit('add')"&gt;对count进行+1操作&lt;/button&gt; &lt;button @click="$store.commit('reduce')"&gt;对count进行-1操作&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; store.js中再修改mutation属性：12345678mutations: &#123; add (state) &#123; state.count += 1 &#125;, reduce (state) &#123; state.count -= 1 &#125;&#125; &#8195;&#8195;运行项目，发现点击按钮就会进行相应的加减操作，在ATest视图操作完了可以跳转去BTest瞧瞧count是不是也相应的改变了。在commit()方法中不仅可以传方法名，也能传入一个参数，通过我们所传入的值来进行加减。具体代码如下：123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是ATest页面&lt;/h1&gt; &lt;h2&gt;全局状态count：&#123;&#123;count&#125;&#125;&lt;/h2&gt; &lt;br&gt; &lt;button @click="$store.commit('add',5)"&gt;对count进行+1操作&lt;/button&gt; &lt;button @click="$store.commit('reduce',5)"&gt;对count进行-1操作&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; store.js中再修改mutation属性：12345678mutations: &#123; add (state,n) &#123; state.count += n &#125;, reduce (state,n) &#123; state.count -= n &#125;&#125; &#8195;&#8195;这样传入是多少，就是进行多少的加减操作。上面说到State有辅助函数mapState，方便对变量的取值，Vuex 倒也是不偏心，Mutations也有辅助函数mapMutations。 通过mapMutations模板获取Mutations方法&#8195;&#8195;实际开发中当然不希望每次提交commit都直接在button的click事件中进行，而mapMutations辅助函数能直接让button的点击事件指向方法名，就像@click=&quot;add&quot;，实现如下：&#8195;&#8195;1、先引用辅助函数mapState:1import &#123;mapMutations&#125; from 'vuex'; &#8195;&#8195;然后在 Vue 的methosd属性中添加mapMutations：123methods: &#123; ...mapMutations(['add','reduce'])&#125; &#8195;&#8195;mapMutations中的数组内的每一个项值就相当于方法名，这样就可以直接在点击事件指向方法名，就像这样：12&lt;button @click="add"&gt;对count进行+1操作&lt;/button&gt;&lt;button @click="reduce"&gt;对count进行-1操作&lt;/button&gt; Vuex 仓库之 Actions&#8195;&#8195;Actions其实就是Mutations的升级版，因为他们的功能基本一样，只不过和 Mutations 不一样的是，Actions 是异步的，而 Mutations 是同步的。同步就是代码必须要一行一行执行，请求必须要一个接着一个，而异步不是这样，不会因为一个请求需要延迟而让后面的代码进行等待(这是我比较浅显庸俗的理解，要是理解得不对望见谅，欢迎纠正！(′▽`〃))。所以，Actions 是可以异步改变state状态的，Mutations 一定是同步改变状态的，废话太多了，直接上代码吧！&#8195;&#8195;首先在store.js中actions添加方法，这里先说明一下，Actions里的方法是可以调用Mutations里的方法的，下面把各类情况都列一下：1234567891011actions: &#123; add_100 (&#123; state &#125;) &#123; state.count += 100 // 此方法就是将count加100, &#123;state&#125;就是仓库的数据源 &#125;, add_call (context) &#123; context.commit('add') // 此方法调用了Mutations中的add方法，content是上下文，其实就是这个store &#125;, reduce_call (&#123; commit &#125;) &#123; commit('reduce') // 此方法调用了Mutations中的reduce方法， &#123;commit&#125;是直接把commit对象传递归来 &#125;&#125; &#8195;&#8195;上面三个方法都是actions里声明的方法，对应参数的解释都写在注释里面了。然后在事件中引用，这个时候不能用$store.commit(String methos) 来引用 actions 方法，因为这个引用方式只适用于 mutations ，引用 actions 需要这样$store.dispatch(String methos)来引入：123&lt;button @click="$store.dispatch('add_100')"&gt;对count进行+100操作&lt;/button&gt;&lt;button @click="$store.dispatch('add_call')"&gt;对count进行+1操作&lt;/button&gt;&lt;button @click="$store.dispatch('reduce_call')"&gt;对count进行-1操作&lt;/button&gt; &#8195;&#8195;既然 State 和 Mutations 都有辅助函数，那 Action 也一定有，毕竟都是 Vuex 的“孩子”，手心手背都是肉！！！同样的，我们需要先引入辅助函数mapAction：1import &#123;mapActions&#125; from 'vuex' 然后同样在 Vue 的 methods 方法集属性里添加辅助函数：123methods: &#123; ...mapActions(['add_100', 'add_call', 'reduce_call'])&#125; &#8195;&#8195;最后在Html部分修改一下button的click指向：123&lt;button @click="add_100"&gt;对count进行+100操作&lt;/button&gt;&lt;button @click="add_call"&gt;对count进行+1操作&lt;/button&gt;&lt;button @click="reduce_call"&gt;对count进行-1操作&lt;/button&gt; &#8195;&#8195;但是现在我们在 actions 里写的都是同步的代码请求，效果和 mutation 一样，那下面我们加点东西，让 actions 展现自己存在的价值，我们在修改一下action的方法：12345678910111213actions: &#123; add_100 (&#123; state &#125;) &#123; state.count += 100 // 此方法就是将count加100, &#123;state&#125;就是仓库的数据源 &#125;, add_call (context) &#123; context.commit('add') // 此方法调用了Mutations中的add方法，content是上下文，其实就是这个store &#125;, reduce_call (&#123; commit &#125;) &#123; // commit('reduce') // 此方法调用了Mutations中的reduce方法， &#123;commit&#125;是直接把commit对象传递归来 setTimeout(() =&gt; &#123; commit('reduce') &#125;, 3000) // 因为没有现成的移步请求，测试移步最好的方法就是加定时器喽 console.log('这一行代码比上面的reduce早执行，reduce会在3秒后执行') &#125;&#125; &#8195;&#8195;具体效果就不截图了，自行运行一下项目，打开控制台你就知道发生了什么。 关于 Getter 和 Model&#8195;&#8195;Vuex 的简单使用方法就这么多，其实还有getter、model两个属性没有将介绍，简单说一下吧！&#8195;&#8195;getter其实就是设置 state 里的一些状态值在每次进行改变的时候都先对这个值进行一些操作的这样一个属性，比如可以在 store 中设置添加getter对count在每次进行加减时进行×10的操作，这个功能主要起到一些过滤作用。&#8195;&#8195;而model呢，就是将上述所讲的state、mutations、actions、getter几个属性进行整合分类，主要用途就是在你的项目后期变得越来越大的时候，那么store里的状态值啊、方法啊都会变得越来越多，而有的状态值都是针对某些特定的业务需求的，那么就可以用model来进行分类，一个model里包含了state、mutations、actions、getter，而store仍然只能有一个，它就可以包含多个model。&#8195;&#8195;这两个属性先这样简单介绍一下吧，后续我再补上其详细用法，见谅！ &#8195;&#8195;来首音乐休息一下吧！ var ap = new APlayer({ element: document.getElementById("aplayer-mPJqZVJs"), narrow: false, autoplay: false, showlrc: 3, music: { title: "起风了", author: "买辣椒也用券", url: "https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/audio/%E8%B5%B7%E9%A3%8E%E4%BA%86.mp3", pic: "https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/poster/%E8%B5%B7%E9%A3%8E%E4%BA%86.jpg", lrc: "https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/lyric/%E8%B5%B7%E9%A3%8E%E4%BA%86%20-%20%E4%B9%B0%E8%BE%A3%E6%A4%92%E4%B9%9F%E7%94%A8%E5%88%B8.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo音乐插件 hexo-tag-aplayer 的坑]]></title>
    <url>%2FHexo%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6%20hexo-tag-aplayer%20%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;博客相信现在好多技术大牛都有，例如博客园、简书、CSDN之类的大型博客网站，但是局限性蛮大的，只能按照网站的规则去写写文章，留个言什么的，要是个人博客就不一样了，可以根据自己的需要去添加任何功能。&#8195;&#8195;在搭建博客时用到hexo-tag-aplayer这样一个音乐插件，可以很优雅地在H5页面中播放音乐，可以算是Hexo框架中最好的音乐插件之一了，体验效果请试听。。。 var ap = new APlayer({ element: document.getElementById("aplayer-zvPpLrrl"), narrow: false, autoplay: false, showlrc: 3, music: { title: "一个人的北京", author: "海鸣威", url: "https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/audio/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.mp3", pic: "https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/poster/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.jpg", lrc: "https://aifeier-123.oss-cn-qingdao.aliyuncs.com/aifeieir-Blog/music/lyric/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC%20-%20%E6%B5%B7%E9%B8%A3%E5%A8%81.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 问题描述&#8195;&#8195;使用hexo-tag-aplayer插件的时候，可以将音乐文件、封面图片放在项目的资源文件夹中，直接引用就行，但是时间长了，项目中的资源文件夹会非常大，严重影响项目的部署效果。插件可以直接引用网络路径，这样就可以将文件上传到阿里云、七牛云之类的对象存储服务器(这里说点废话，阿里云对象存储需要money，但是不是很贵，七牛云普通用户就可以享受10G的免费存储空间，其他的云平台自己百度)，然后复制粘贴文件URL就可以实现上面音乐播放器的效果。&#8195;&#8195;问题在这，这个插件也可以设定歌曲的歌词，不过也需要引用歌词文件(一般都是lrc格式，也有txt格式等)，同样将歌词文件上传到相应的云平台上,然后拷贝文件路径粘贴一下，部署，发现歌词没显示出来，F12查看控制台，发现说歌词文件访问不了，存在跨域问题，绝了都！！！&#8195;&#8195;为啥封面图片就可以直接配置网络路径访问呢？开始没想到在云平台进行相应的设置，光在自己博客项目一顿倒腾，没整出来，简直了。&#8195;&#8195;后来直接上插件的GitHub开源项目的issues讨论里面溜达一圈，希望能找到一点线索。果然，不管是我一个人有这样的问题，插件目前的维护者给出的解决办法如下：&#8195;&#8195;跨域限制是浏览器为了防止诸如 CSRF 等攻击所采取的安全措施，如果歌词文件是遇到跨域问题，请考虑将歌词文件放到同源网站（如 https://www.xxwhite.com ）再进行请求，或者如果有歌词文件所在服务器的权限，请在歌词文件资源返回的 HTTP 头中添加 Access-Control-Allow-Origin 字段。&#8195;&#8195;绝了都，歌词为什么就不能像封面图片直接通过访问资源拿到呢？就不能弄得和封面图片一个吗？算了，小白的我不懂大神的难处，只能照着维护者的意思解决喽。 解决办法&#8195;&#8195;到云平台将资源文件设置一下 HTTP 头，解决跨域问题，因为博主用的是阿里云，所以以下内容暂针对阿里云OSS对象存储进行解决跨域问题。&#8195;&#8195;在阿里云控制台中选择“对象存储OSS”菜单，在选择你存放资源的那个Bucket(什么是Bucket，就是一个自己添加的存储空间)，然后选择“基础设置” – &gt; “跨域设置”。&#8195;&#8195;然后点击“创建规则”，接着照着我的填写和勾选。&#8195;&#8195;接着点击确定，再回去你的博客看看歌词是不是出来了。&#8195;&#8195;还有一个小插曲，如果个人博客的域名用的是HTTPS头，那么所引用的资源文件也必须要是HTTPS头的，阿里云OSS对象存储可以直接将文件设置HTTPS头，其他的云平台自行设置，后续有机会可以再续上七牛云的设置方法。其实这也不是什么很难的问题，就是自己遇上了，记录一下。]]></content>
      <categories>
        <category>前端</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-tag-aplayer</tag>
        <tag>音乐插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli项目中rem布局的配置]]></title>
    <url>%2Fvue-cli%E9%A1%B9%E7%9B%AE%E4%B8%ADrem%E5%B8%83%E5%B1%80%E7%9A%84%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[今天在用 Vue 重构一个项目的遇到一个css单位问题——rem布局。rem自适应布局是前端在移动端页面中常用的手法，这次重构的项目就是一个移动端H5项目，用vue搭建首页后发现css中同样用的是rem单位，在Chrome中调试时却发现被定义元素的宽高明显不一样。 rem简单描述&#8195;&#8195;rem和px的比例其实是可以自行去设置相应的比例，并不是固定的一个值。我们往往直接在H5中使用rem去定义元素的属性值，所显示rem和px比例值都是浏览器的默认比例1rem = 16px，所以如果给一个div定义宽度width: 1rem，那么在浏览器默认是width: 16px。&#8195;&#8195;是不是很好奇为什么1rem = 16px，这样太不好计算了，如果我需要一个元素的宽度是100px，如果要用rem去定义的话就是100px / 16 = 6.25rem，不仅不是整数，而且计算也麻烦，所以我们该怎么办才能让rem被使用的更加顺手呢？前面说过，rem和px是可以自行去设置比例，，如果在H5页面的html标签里设置font-size: 62.5%，那么相当于此页面中默认字体的大小是10px，也就是1rem = 10px，好算又好看。 vue中的解决办法&#8195;&#8195;既然在Html的页面的html标签中直接设置font-size就可以改变rem和px的比例，那么是不是直接在Vue项目中的index.html入口文件的中也设置一下font-size呢？当然不是这样！在实际使用中有很多不同的移动端设置，他们相对应的font-size也当然要不一样，所以需要自适应配置rem。&#8195;&#8195;办法就是使用js去改变比例，通过js去操作入口文件的 Html DOM 去改变font-size的值，js内容的写法有很多，这里贴出所使用的代码。12345678910111213// iphone6 为基准 rem 布局 ，iphone6 的宽高是375*667(function (doc, win) &#123; var docEl = doc.documentElement var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize' var recalc = function () &#123; var clientWidth = docEl.clientWidth if (!clientWidth) return docEl.style.fontSize = (clientWidth / 37.5) + 'px' &#125; if (!doc.addEventListener) return win.addEventListener(resizeEvt, recalc, false) doc.addEventListener('DOMContentLoaded', recalc, false)&#125;)(document, window) &#8195;&#8195;这里说一下实现步骤，先在Vue项目的src目录下新建一个comment文件夹，然后再文件夹内新建rem.js，将上面代码复制进去，保存。最后在src目录下的main.js文件中添加import &#39;../comment/rem&#39;，完事。 遇到的坑坑1&#8195;&#8195;在找到解决办法后还遇到一个“不算问题”的问题，那就是谷歌浏览器Chrome给我造成的问题。通过上述办法设置rem和px比例为1rem = 10px,然后设置一个div元素的高度为7rem，然后在调试器中却发现一直是84px，按照比例计算应该是70px，找了好久找不出问题原因。后来突然灵光一闪，想起来谷歌浏览器的默认字体大小最小为12px，无论怎么设置字体大小都不能小于12px，即使你设置1px，最后也会发现是12px，所以谷歌浏览器的rem和px比例最小是1rem = 12px。最后只能修改比例，改成1rem = 20px。 坑2&#8195;&#8195;虽然设置好了rem比例，但是移动端的设备也有个别型号比较麻烦的，就像iPad Pro(1024 × 1366)，或者要是把移动端项目放在PC端上，会发现设备宽度越宽，那页面的元素也会按照比例被放大很多，导致视觉体验效果特别不好，所以我们的js代码仍需要优化，需要进行最大宽度判断。完整代码如下：1234567891011121314151617// iphone6 为基准 rem 布局 ，iphone6 的宽高是375*667(function (doc, win) &#123; var docEl = doc.documentElement var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize' var recalc = function () &#123; var clientWidth = docEl.clientWidth if (!clientWidth) return if (clientWidth &gt; 768) &#123; docEl.style.fontSize = '40px' &#125; else &#123; docEl.style.fontSize = 1 * (clientWidth / 18.75) + 'px' &#125; &#125; if (!doc.addEventListener) return win.addEventListener(resizeEvt, recalc, false) doc.addEventListener('DOMContentLoaded', recalc, false)&#125;)(document, window)]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目前流行的前后端框架技术列举]]></title>
    <url>%2F%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E5%88%97%E4%B8%BE.html</url>
    <content type="text"><![CDATA[&#8195;&#8195;这是本博客的第一篇文章，不知道是该写点什么东西才好，正好自己平时比较喜欢浏览一些公总号上的技术文章，这两天看到几篇对目前比较前沿的、使用人数较多的(流行的)前后端技术，这里我整合记录一下，算是给自己往后的学习列一个大纲。 后端&#8195;&#8195;Java目前是业内使用的编程语言中占据最高的地位，毕业生初入社会要是从事后端工作的话，大多都会投递从事Java开发的简历，所以Java这门编程语言，应该是很多后端程序员必备的基础技能，甚至可以说是“吃饭的家伙”。&#8195;&#8195;即使目前自己从事前端开发工作，但也会学习后端基础，多了解了解总有好处。这里列举一下对博主而言目前比较重要的一些Java Web框架，并且都上网查了每个框架的官网和github上的源码，可能没有太大的必要，但是还是记录一下吧。 Spring&#8195;&#8195;Spring这个词相信只要是程序员，就算不知道是干吗的，但至少也听说过。Spring是一个开放源代码的设计层面框架，它解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用(描述得有点官方化，摘自百度百科)。&#8195;&#8195;说点大家都听得懂得吧，Spring是Java后端框架里最强大的，从字面上理解是“春天”的意思，那就是我们程序员的春天，自然是最牛的。Spring的优点就不一一列举了，大多情况下我也只是会用，不太理解框架的底层原理，真是惭愧，这点的确是需要进步滴。Spring 有 IOC 和 AOP 两大利器，大大简化了软件开发复杂性。总而言之，Spring就是很好，让Java开发更加简单。官网：https://spring.io/projects/spring-framework 源码：https://github.com/spring-projects/spring-framework Spring MVC&#8195;&#8195;Spring MVC就是一个MVC框架，它类似于Struts的一个MVC开框架，其实都是属于Spring，Spring MVC需要有Spring的架包作为支撑才能跑起来，是Spring项目的重要成员，主要也是也是让Java开发变得更加简答。官网：https://spring.io/projects/spring-framework 源码：https://github.com/spring-projects/spring-framework Spring Boot&#8195;&#8195;Spring Boot 是 Spring 开源组织下的一个子项目，个人感觉它最大的优点就是简化了需要配置文件，把Spring有关的各种xml配置文件都压缩成一个，让Spring开始使用起来更加简答。再有一个特点就是，这个东东居然自己集成了Tomcat，也就是它内置Tomcat启动。官网：https://spring.io/projects/spring-boot 源码：https://github.com/spring-projects/spring-boot Spring Cloud&#8195;&#8195;Spring Cloud 是一系列框架的有序集合，是目前最火热的微服务框架首选，它利用Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署(摘自百度百科主要博主也没用这个框架，不是很了解，后续可以一起学习交流)。官网：http://projects.spring.io/spring-cloud/ 源码：https://github.com/spring-cloud Mybatis/ iBatis&#8195;&#8195;Mybatis是一款持久层(简单理解持久层就是，直接操作数据库那一层)框架，它支持定制化 SQL、存储过程以及高级映射。这个框架就是让我们在进行Java开发时，在对数据进行增删改查时显得更加优雅、高效。官网：http://www.mybatis.org/mybatis-3/ 源码：https://github.com/mybatis Dubbo&#8195;&#8195;很早就知道分布式服务这个概念，一直也很想学习了解一下。Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案。RPC 指的是远程调用协议，也就是说两个服务器交互数据。它能干吗？简单来说，用户发送的请求转交给 Nginx，然后 Nginx 决定将请求发送那个服务器（此处为 Tomcat），然后 Tomcat 将请求发送给 Dubbo，由它来决定继续调用哪个 service 层去数据库读取数据(摘自简书博客文章)。官网：http://www.mybatis.org/mybatis-3/ 源码：https://github.com/mybatis Netty&#8195;&#8195;Netty 是由 JBOSS 提供的一个开源的、异步的、基于事件驱动的网络通信框架，用 Netty 可以快速开发高性能、高可靠性的网络服务器和客户端程序，Netty 简化了网络应用的编程开发过程，使开发网络编程变得异常简单。官网：https://netty.io/ 源码：https://github.com/netty/netty Shiro&#8195;&#8195;Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。官网：http://shiro.apache.org/ 源码：https://github.com/apache/shiro Ehcache&#8195;&#8195;EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的CacheProvider。它使用的是 JVM 的堆内存，超过内存可以设置缓存到磁盘，企业版的可以使用 JVM 堆外的物理内存。官网：http://www.ehcache.org/ 源码：https://github.com/ehcache/ehcache3 JUnit&#8195;&#8195;JUnit 是一个 Java 语言的单元测试框架，绝大多数 Java 的开发环境都已经集成了 JUnit 作为其单元测试的工具。官网：https://junit.org 源码：https://github.com/junit-team/ Log4j&#8195;&#8195;Log4j 是 Apache 的一个开源日志框架，通过 Log4j 我们可以将程序中的日志信息输出到控制台、文件等来记录日志。作为一个最老牌的日志框架，它现在的主流版本是 Log4j2。Log4j2是重新架构的一款日志框架，抛弃了之前 Log4j 的不足，以及吸取了优秀日志框架 Logback 的设计。官网：https://logging.apache.org/log4j/2.x/ 源码：https://logging.apache.org/log4j/2.x/source-repository.html 前端&#8195;&#8195;前端，是近几年火起来的岗位，听说在以前，并没有“前端”这个岗位称呼，不过好像有叫网页制作的岗位，应该就是现在前端的前身了，工作内容就是画画网页页面，实现页面交互功能，好像并不是大多程序员的首选岗位。现在不一样了，前端近几年的技术栈更新的特别快，尤其是Node.js，那更是让我喜欢。下面同样也列出一些前端上的技术框架。 NodeJs&#8195;&#8195;Node.js是一个Javascript运行环境，是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。简单的说 Node.js 就是运行在服务端的 JavaScript。以上从百度百科和菜鸟教程借鉴过来混合描述了一下Node.js。&#8195;&#8195;用自己的话简单描述一下 Node.js 吧。首先我们要确定一个正确的概念，Node.js不是JavaScript框架，应该算一个开发环境，这样说吧，安装了Node.js，就可以通过命令行下载目前网络上各种组件依赖，从而搭建起来前端项目。Node本身也算是一种后台语言，也就是用JS语言实现后台功能，大多是前端工程师在用。官网：https://nodejs.org/en/ 源码：https://github.com/nodejs/node/tree/master/lib/internal Vue&#8195;&#8195;Vue是目前国内比较火的前段框架，是一套构建用户界面的渐进式框架。Vue是我毕业实习所学习的第一个前端框架，上手不难，看着官方文档学习能很快掌握用法。先说说Vue最大的优点就是，相比传统的用Js或者jQuery去操作Dom来进行页面数据的渲染，Vue能直接将数据和Html元素进行连接，实时更新，减少了前端的工作量，光说不如直接去实践。官网：https://cn.vuejs.org/ 源码：https://github.com/vuejs/vue React&#8195;&#8195;StateOfJS 表示，React 拥有JavaScript框架里最大的市场份额，大概占比64.8%。只不过这个框架我没用过，既然这么多人在用，应该也是一个很值得去学习的。官网：https://reactjs.org/ 源码：https://github.com/facebook/react/ Redux&#8195;&#8195;Redux 是使用最广泛的工具，82％ 的满意率也证明了它的成熟程度。这是JavaScript的数据层工具，之前也没有用过，先记录一下，后续有机会可以学习。官网：https://www.redux.org.cn/ 源码：https://github.com/reduxjs/redux Express&#8195;&#8195;在搭建此博客之前，我并不知道有Hexo这样一个能够快速构建个人博客的前段框架，打算想自己写一个，再一次偶然的机会，我在一些技术贴上看到了一个JavaScript的后台框架Express，能够用JS语言搭建基于Node.js的后端，这让我眼前一亮，既然目前是前段开发，就心想直接用JS去做一整套包括前后端的个人博客网站吧，而且能根据我自己的需求去设计自己想要的功能。&#8195;&#8195;说做就做了，我一边学习一边实践，陆陆续续经过两三个月实现了一个简单的个人博客。不多说了，后续有时间我将搭建过程写出来分享给大家。官网：http://www.expressjs.com.cn/ 源码：https://github.com/expressjs/express Mocha&#8195;&#8195;调查显示，Mocha 仍然是最常用的单元测试框架。它已经存在了很长一段时间，拥有最大的生态系统。 Electron&#8195;&#8195;Electron是使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用官网：https://electronjs.org/ 源码：https://github.com/electron 其他的&#8195;&#8195;以上就是自己搜集的前后端技术框架，但是目前技术更新太快，可能有其他更加好更加便捷的框架，所以本文内容仅供参考。&#8195;&#8195;除了编程语言、框架技术，我们还需要了解一下其他的开发有关的东西，如编译器、服务器、版本管理工具等等。。。&#8195;&#8195;Java开发工具推荐使用 IntelliJ IDEA ，用过的朋友朋友当然最好，没有用过朋友的建议早点接触使用，目前对于 Java 开发来说，个人感觉这是最好用的编译器了。前端的话推荐使用 Visual Studio Code，这也是我自己才开始使用的前段编辑器，之前也听过，一直觉得应该和 Sublime 差不多，但是一次偶然的机会下载使用了一次，便发现没有比这更适合我的前端开发工具了。&#8195;&#8195;服务器，我目前一直使用的是阿里云，阿里云有一个云翼计划，24岁以下用户自动默认为学生用户，可以购买一年114.00元的服务器(1核2G，带宽1M，40G空间，购买链接)，个人觉得相当实惠(声明，没有给阿里云打广告，只是因为真的喜欢阿里云产品)。服务器系统直接 Linux 吧，因为 WinService 和我们所使用的 Windows 没什么操作上的区别，对自己的提升不大。&#8195;&#8195;版本管理工具就 Git 喽，这些网上教程都很多，SVN也可以试着了解一下，可能有些公司内部会有用到。 &#8195;&#8195;学无止境，IT 行业更是如此。]]></content>
      <categories>
        <category>技术列举</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
